<html>

<head>
<title>Методические указания к выполнению курсовых работ по курсу "Системное програмирование"</title>
</head>

<body bgcolor=#F5DEB3 leftmargin="0" topmargin="0" rightmargin="0" bottommargin="0" marginwidth="0">
<center>
<table border="3">
<tr>
<td width="700"> <font color="#0000FF">
<h2><center>18.Проецирование файлов (File Mapping).</center></h2>
<p align="justify">&nbsp&nbsp&nbspРазработать программу, которая позволяет обмениваться данными с другой такой же программой, используя проецируемые файлы.</p>
</td>
<tr>
<td bgcolor="#FFFAFA" width="700"><center><h3><font color="#00008B"></font></h3></center>   

<center><h3><font color="#00008B">Создание объекта "проецируемый файл"</font></h3></center>   

<p align="justify">
Первый шаг в отображении файла - это открытие файла при помощи вызова функции CreateFile. Чтобы гарантировать, что другие процессы не смогут писать в части файла, которая отображается, вам следует открыть файл с монопольным доступом. Кроме того, дескриптор файла должен оставаться открытым до тех пор, пока у процесса не исчезнет нужда в объекте "проецируемый файл". Легкий способ получить монопольный доступ состоит в том, чтобы установить нуль в параметре dwShareMode функции CreateFile. Дескриптор, возвращенный CreateFile используется функцией CreateFileMapping, чтобы создать объект "проецируемый файл".</p>

<p align="justify">
Функция CreateFileMapping возвращает дескриптор  объекта "проецируемый  файл". Этот дескриптор должен использоваться при создании представления файла так, чтобы Вы могли получить доступ к совместно используемой памяти. Когда Вы вызываете CreateFileMapping, то задайте имя объекта, число байтов, которые отобразятся из файла и разрешение чтения - записи в отображаемой памяти. Первый процесс, который вызывает функцию CreateFileMapping, создает объект "проецируемый файл". Процессы, вызывающие CreateFileMapping для существующего объекта получают его дескриптор. Вы можете убедиться, успешно или нет завершился вызов  CreateFileMapping, который создавал или открывал объект "проецируемый файл", при помощи вызова функция GetLastError. GetLastError возвращает значение NO_ERROR создающему процессу и ERROR_ALREADY_EXISTS последующим процессам.</p>

<p align="justify">
Функция CreateFileMapping завершается ошибкой, если флажки доступа находятся в противоречии с  установленными тогда, когда функция CreateFile открывала файл. Например, чтобы читать и записывать в файл:</p>

<ul>
	<li>Установите значения GENERIC_READ и GENERIC_WRITE в параметре fdwAccess функции CreateFile.</li>
	<li>Установите значение PAGE_READWRITE в параметре fdwProtect функции CreateFileMapping.</li>
</ul>

<p align="justify">Процедура создания объекта "проецируемый файл" не закрепляет физическую память, она только резервирует её.</p>

<p align="justify"><strong>Размер проецируемого в память файла</strong></p>

<p align="justify">Размер объекта "проецируемый файл" не зависит от размера отображаемого файла. Однако, если объект "проецируемый файл" является большим чем файл, система увеличивает файл до возвращения значения функцией CreateFileMapping. Если объект "проецируемый файл" является меньшим чем файл, система проецирует только определенное число байтов из файла.</p>

<p align="justify">Параметры dwMaximumSizeHigh и dwMaximumSizeLow функции CreateFileMapping дают возможность устанавливать число байтов, которые будут отображаться из файла:</p>

<ul>
	<li>Windows 95/98/Me: Параметр dwMaximumSizeHigh не используется, потому что эти операционные системы не поддерживаются 32-разрядной файловой системой. Это значение должно быть - нуль.<br>Если Вы не хотите изменять размер файла (например, когда отображаете файл только для чтения) вызовите функцию CreateFileMapping и установите оба её параметра dwMaximumSizeHigh и dwMaximumSizeLow в нуль. Выполнение этого приема создает объект "проецируемый файл" точно такого же размера, как и файл. В противном случае, Вы должны вычислить или приблизительно подсчитать размер законченного файла, потому что объекты "проецируемый файл" являются статическими по размеру; после создания их размер не может увеличиться или уменьшиться. Попытка проецировать файл с нулевой длиной этим способом завершается ошибкой с кодом ошибки ERROR_FILE_INVALID. Программы должны обнаруживать файлы с нулевой длиной и отвергать такие файлы:</li>
	<li>Windows NT/2000 или выше: Размер объекта "проецируемый файл", примыкаемого к именованному файлу ограничен дисковым пространством. Размер представления файла ограничен наибольшим доступным непрерывным блоком незарезервированной виртуальной памяти. Это - самое большее - 2 Гбайта минус виртуальная память, ранее зарезервированная процессом.</li>
	<li>Windows 95/98/Me: Размер объекта "проецируемый файл", примыкаемого к именованному файлу также ограничен дисковым пространством. Размер представления файла ограничен наибольшим доступным непрерывным блоком незарезервированной виртуальной памяти в совместно используемом адресном пространстве. Это - самое большее 1 Гбайт минус виртуальная память используемая другими процессами, такими как 16-разрядные базирующиеся на Windows приложения или базирующиеся на Win32 прикладные программы, которые используют отображение (проецирование) файла в память.</li>
</ul>

<p align="justify">Размер объекта "проецируемый файл" выбирается при помощи контроля, как далеко в файле  с отображением в памяти Вы можете "видеть". Если Вы создаете 500 килобайтный объект "проецируемый файл" , Вы имеете доступ только к первым 500 КБ файла, независимо от  размера его файла. Так как, чтобы создать больший объект "проецируемый файл", не требуется от Вас  системных ресурсов, создайте его по размерам одинаковым с  файлом (установив нули в обоих параметрах dwMaximumSizeHigh и dwMaximumSizeLow функции CreateFileMapping), даже если Вы не предполагаете просматривать весь файл. В затраты системных ресурсов входит создание представлений и доступа к ним.</p>

<p align="justify">Если Вы хотите просмотреть часть файла, которая  начинается не в начале файла, Вы должны создать объект "проецируемый файл". Этот объект - размер части файла, который Вы хотите просмотреть плюс смещение в файле.</p>

<center><h3><font color="#00008B">Создание представления файла</font></h3></center>

<p align="justify">Чтобы спроецировать данные из файла в виртуальную память процесса, Вы должны создать представление файла. Функции MapViewOfFile и MapViewOfFileEx используют дескриптор объекта "проецируемый файл", возвращенный CreateFileMapping, чтобы создать представление файла или его части в виртуальном адресном пространстве процесса. Эти функции завершаются ошибкой, если флажки доступа находятся в противоречии с флажками определенными тогда, когда CreateFileMapping создавала объект "проецируемый файл".</p>

<p>Функция MapViewOfFile возвращает  указатель на представление файла. При помощи разыменования ( получения значения объекта, к которому отсылает данный указатель) указателя в диапазоне адресов, определенных в функции MapViewOfFile, приложение может читать данные из файла и писать данные в файл. Запись в представление файла происходит в результате изменений в объекте "проецируемый файл ". Фактическая запись в файл на диске обрабатывается системой. Данные в действительности не перемещаются, когда идет запись в объект "проецируемый файл". Вместо этого, большая часть файлового ввода и вывода (I/O) данных  кэшируется, чтобы улучшить общую производительность системы. Приложения могут отменить этот режим работы при помощи вызова функции FlushViewOfFile, чтобы заставить систему выполнять дисковые транзакции (групповые операции) немедленно.</p>

<p align="justify">Функция MapViewOfFileEx работает в точном соответствии с функцией MapViewOfFile за исключением того, что она дает возможность процессу  в параметре lpvBase установить базовый адрес представления файла в его виртуальном адресном пространстве. Если по указанному адресу недостаточно места, вызов завершается ошибкой. Поэтому, если Вы должны проецировать файл, по одному и тому же адресу в несколько процессов, процессы должны договориться о соответствующем адресе:</p>

<ul>
	<li>Windows NT/2000 или выше: Параметром lpvBase  должно быть целое число, кратное степени дробления распределенной оперативной памяти, или вызов завершается ошибкой. Чтобы получить степень дробления распределенной оперативной памяти, используйте функцию GetSystemInfo, которая заполняет поля в членах структуры SYSTEM_INFO.</li>
	<li>Windows 95/98/Me: Адрес округляется вниз до ближайшего целого числа, кратного степени дробления распределенной оперативной памяти. Для последующих представлений файла, если указанный адрес не соответствует адресу, в который система отобразила представление файла, работа MapViewOfFileEx завершается ошибкой.</li>
</ul>

<p align="justify">Приложение может создать несколько представлений файла из одного и того же объекта "проецируемый файл". Представление файла может быть другим по размеру, чем объект "проецируемый файл", из которого оно получено, но оно должно быть меньше, чем объект "проецируемый файл". Смещение, задаваемое параметрами dwOffsetHigh и dwOffsetLow  функции MapViewOfFile должно быть кратно степени дробления распределенного пространства системы.</p>

<center><h3><font color="#00008B">Закрытие объекта "проецируемый файл"</font></h3></center>

<p align="justify">Когда процесс заканчивает работу с объектом "проецируемый файл", он должен уничтожить все представления файла в своем адресном пространстве, используя функцию UnmapViewOfFile для каждого представления файла. Эта функция аннулирует указатель на виртуальное адресное пространство процесса. Если какая - либо из страниц представления файла изменилась, с тех пор как представление было отображено, система записывает измененные страницы файла на диск, используя кэширование. Чтобы передать данные на диск немедленно, вызовите функцию FlushViewOfFile перед  прекращением отображения представления файла.</p>

<p align="justify">Вы должны вызвать функцию CloseHandle, чтобы сначала закрыть объект "проецируемый файл", а затем закрыть файл на диске. Эти вызовы CloseHandle завершаются успешно, даже тогда,  когда есть представления файла, которые все еще являются открытыми. Однако, оставшиеся отображения представлений файла становятся причиной утечки памяти.
</p>


</td></tr>
</table>
</center>
<br><br><font color="#0000FF"><a href="index.html">Вернуться к списку тем.</a></font>

</body>


</html>