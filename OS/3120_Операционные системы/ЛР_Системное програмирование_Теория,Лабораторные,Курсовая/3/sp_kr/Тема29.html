<html>

<head>
<title>Методические указания к выполнению курсовых работ по курсу "Системное програмирование"</title>
</head>

<body bgcolor=#F5DEB3 leftmargin="0" topmargin="0" rightmargin="0" bottommargin="0" marginwidth="0">
<center>
<table border="3">
<tr>
<td width="700"> <font color="#0000FF">
<h2><center>29.Инструментальная библиотека (Tool Help Library).</center></h2>
<p align="justify">&nbsp&nbsp&nbsp</p>
</td>
<tr>
<td bgcolor="#FFFAFA" width="700"><center><h3><font color="#00008B">Библиотека Tool Help для Windows</font></h3></center>   

<p align="justify">Данная библиотека позволяет получить информацию о состоянии работающих на локальном компьютере приложений. Вообще говоря, библиотека предназначена для написания всякого рода отладчиков, но область ее применения на самом деле заметно шире.</p>

<p><strong>Снимки системы</strong></p>

<P align="justify">В основе THL лежит понятие «snapshot» – мгновенного снимка состояния запущенных приложений. Перед вызовом всех функций библиотеки необходимо создать snapshot. Это осуществляется вызовом функции </P>

<PRE>HANDLE WINAPI CreateToolhelp32Snapshot
(DWORD dwFlags, DWORD th32ProcessID );</PRE>

<P align="justify">Параметр dwFlags указывает, какая именно информация интересует пользователя. Его значения приведены в Таблице 1.</P>

<P align="justify">Параметр th32ProcessID идентифицирует процесс, состояние которого исследуется. Он необходим при использовании dwFlags со значениями TH32CS_SNAPHEAPLIST, TH32CS_SNAPMODULE и TH32CS_SNAP-THREAD. В остальных случаях этот параметр игнорируется.</P>

<P align="justify">Так, например, для получения списка модулей процесса dwProcessID необходим следующий вызов:</P>

<PRE>hSnapshot = CreateToolhelp32Snapshot
( TH32CS_SNAPMODULE,dwProcessID );</PRE>

<P align="justify">Уничтожается объект snapshot стандартным вызовом CloseHandle( hSnapshot );</P>

<P align="justify">Все ошибки, возникающие при выполнении функций THL, возвращаются стандартным вызовом GetLast-Error и FormatMesssage.</P>

<p><strong>Список процессов</strong></p>

<P align="justify">В примере используются две функции:</P>

<PRE>BOOL WINAPI Process32First(  HANDLE 
hSnapshot, LPPROCESSENTRY32 lppe )</PRE>

<P>и</P>

<PRE>BOOL WINAPI Process32Next(  HANDLE
 hSnapshot, LPPROCESSENTRY32 lppe ).</PRE>

<P align="justify">В обеих функциях два параметра. Первый – дескриптор, возвращаемый предыдущим вызовом CreateToolhelp-32Snapshot, а второй указывает на структуру PROCESSENTRY32, в которой возвращается результат выполнения функции. Перед вызовом Process32First необходимо установить в поле dwSize структуры PROCES-SENTRY32 значение, равное размеру самой структуры – sizeof(PROCES-SENTRY32), иначе функция вернет ошибку. </P>

<p><strong>Список модулей, загруженных процессом</strong></p>

<P align="justify">В процессе работы практически любого приложения Win32 загружаются те или иные библиотеки, компоненты и другие программные модули. Естественно, возникает желание получить список загруженных модулей. Для этого в THL также предусмотрен простой механизм.</P>

<P align="justify">В нем, в первую очередь, вызывается CreateToolhelp32Snapshot с параметрами TH32CS_SNAPMODULE и идентификатором процесса, модули которого нас интересуют. Далее, как и в предыдущем примере, в поле dwSize, но теперь уже структуры MODULEENTRY32, устанавливается значение, равное ее размеру. Кстати, это необходимо делать для всех функций перечисления THL. </P>

<P align="justify">Цикл перебора ничем не отличается от рассмотренного в предыдущем примере. Разве что он использует структуру MODULEENTRY32, в которую возвращается информация о модуле. Описание полей этой структуры содержится в Таблице 2.</P>

<p><strong>Потоки процесса</strong></p>

<P align="justify">Механизм работы с потоками процесса идентичен механизму, описанному для модулей, только вызываются функции Thread32First и Thread32Next, а вместо структуры MODULEENTRY32 используется THREADENTRY32.</P>

<p><strong>Доступ к памяти процесса</strong></p>

<P align="justify">Известно, что в Win32 получить доступ к памяти одного процесса из другого невозможно. Тем не менее в THL есть функция, позволяющая получить копию блока памяти другого процесса:</P>

<PRE>BOOL WINAPI Toolhelp32Read
ProcessMemory
( DWORD th32ProcessID, LPCVOID
 lpBaseAddress, 
 LPVOID lpBuffer,  DWORD cbRead,
 LPDWORD
 lpNumberOfBytesRead  );</PRE>
 
<P align="justify">Параметры у этой замечательной функции следующие:</P>

<PRE>th32ProcessID</PRE> 

<P align="justify">[in] Идентификатор процесса, блок памяти которого необходимо скопировать. Если этот параметр равен нулю, то копируется память из текущего процесса. </P>

<PRE>lpBaseAddress</PRE> 

<P align="justify">[in] Адрес в адресном пространстве указанного процесса, начиная с которого копируется информация. Перед выполнением операционная система проверяет, вся ли указанная память доступна для чтения. Если это не так, возвращается FALSE. </P>

<PRE>lpBuffer</PRE> 

<P align="justify">[out] Указатель на буфер, в который должны быть скопированы данные. </P>

<PRE>cbRead </PRE>

<P>[in] Размер буфера в байтах. </P>

<PRE>lpNumberOfBytesRead </PRE>

<P>[out] Количество скопированных байтов.</P>

<P align="justify">А как узнать, где в адресном пространстве процесса находятся данные? В самом общем случае на этот вопрос ответить невозможно. Но для динамически распределяемой памяти (heap) THL предоставляет функции, эту проблему решающие.</P>

<p><strong>Исследование динамической памяти процесса</strong></p>

<P align="justify">Для выделения области в виртуальной памяти используется функция HeapCreate, которая создает соответствующий объект (heap) в адресном пространстве процесса. Для выделения памяти внутри этого блока используется  функция HeapAlloc. Все остальные функции работы с динамической памятью (GlobalAlloc, malloc, calloc и т. д.) сводятся к использованию этого механизма, который мы не будем здесь подробно рассматривать.</P>

<P align="justify">Очевидно, что нужно уметь находить список выделенных областей виртуальной памяти и для каждого из них – список выделенных блоков. Посмотрим, как это делается с помощью функций THL. В терминах THL область памяти называется heap, множество областей памяти – heap list, а выделенному внутри нее блоку соответствует термин «block of a heap».</P>

<P align="justify">Первый цикл с помощью функций Heap32ListFirst и Heap32ListNext возвращает список блоков памяти, которые были распределены. Зная идентификатор процесса и идентификатор области виртуальной памяти, который возвращается в поле th32HeapID  структуры HEAPLIST32, можно просмотреть, как распределяется память внутри этого блока. Выделенные области памяти можно получить с помощью функций Heap32First и Heap32-Next. Они возвращают структуру HEAPENTRY32, описание полей которой приведено в Таблице 3.</P>

<P align="justify">Зная значения полей dwAddress и dwBlockSize, с помощью функции Toolhelp32ReadProcessMemory нетрудно получить данные, находящиеся в динамической памяти процесса.</P>

<hr>

<TABLE BORDER=1><CAPTION ALIGN=top><B>Таблица 1. Значения параметра dwFlags-функции. CreateToolhelp32Snapshot.</B></CAPTION>
<tr><td>TH32CS_INHERIT</td><td>показывает, что snapshot был унаследован.</td></tr>
<tr><td>TH32CS_SNAPHEAPLIST </td><td>получает список блоков динамически распределенной памяти в адресном пространстве процесса.</td></tr>
<tr><td>TH32CS_SNAPMODULE </td><td>получает список модулей, загруженных процессом.</td></tr>
<tr><td>TH32CS_SNAPPROCESS </td><td>получает список запущенных на локальном компьютере процессов.</td></tr>
<tr><td>TH32CS_SNAPTHREAD </td><td>получает список потоков процесса.</td></tr>
<tr><td>TH32CS_SNAPALL </td><td>включает в себя предыдущие четыре флага, т. е. snapshot будет содержать списки процессов, потоков, модулей и областей динамической памяти.</td></tr></TABLE>
<HR>
<TABLE BORDER=1><CAPTION ALIGN=top><B>Таблица 2. Описание полей структуры MODULEENTRY32.</B></CAPTION>
<tr><td>DWORD   dwSize </td><td>размер структуры в байтах</td></tr>
<tr><td>DWORD   th32ModuleID </td><td>ID модуля</td></tr>
<tr><td>DWORD   th32ProcessID </td><td>ID процесса модуля</td></tr>
<tr><td>DWORD   GlblcntUsage </td><td>общее для системы количество обращений к модулю</td></tr>
<tr><td>DWORD   ProccntUsage </td><td>количество обращений к модулю, сделанных из текущего процесса</td></tr>
<tr><td>BYTE  * modBaseAddr </td><td>адрес модуля в адресном пространстве процесса</td></tr>
<tr><td>DWORD   modBaseSize </td><td>размер модуля</td></tr>
<tr><td>HMODULE hModule </td><td>дескриптор модуля в контексте процесса</td></tr>
<tr><td>TCHAR   szModule [MAX_MODULE_NAME32 + 1]  </td><td>имя модуля</td></tr>
<tr><td>TCHAR   szExePath[MAX_PATH] </td><td>полный путь к файлу</td></tr></TABLE>
<HR>
<TABLE BORDER=1><CAPTION ALIGN=top><B>Таблица 3. Описание полей структуры HEAPENTRY32.</B></CAPTION>
<tr><td>SIZE_T  dwSize </td><td>размер структуры HEAPENTRY32 в байтах.</td></tr>
<tr><td>HANDLE  hHandle </td><td>дескриптор блока памяти в адресном пространстве процесса.</td></tr>
<tr><td>ULONG_PTR  dwAddress </td><td>адрес начала блока памяти.</td></tr>
<tr><td>SIZE_T  dwBlockSize </td><td>размер блока памяти.;</td></tr>
<tr><td>DWORD   dwFlags </td><td>флаги, описывающие область памяти. Этот параметр может принимать следующие значения:</td></tr>
<tr><td>LF32_FIXED </td><td>область памяти не может быть перемещена операционной системой;</td></tr>
<tr><td>LF32_FREE </td><td>блок памяти не используется;</td></tr>
<tr><td>LF32_MOVEABLE </td><td>область памяти выделена и может перемещаться.</td></tr>
<tr><td>DWORD   dwLockCount </td><td>количество вызовов функции GlobalLock (в Win32 LocalLock синоним функции GlobalLock), которые были сделаны для этого блока памяти.</td></tr>
<tr><td>DWORD   dwResvd </td><td>зарезервировано.</td></tr>
<tr><td>DWORD   th32ProcessID </td><td>ID процесса, в контексте которого выделена память.</td></tr>
<tr><td>ULONG_PTR  th32HeapID </td><td>идентификатор блока памяти, выделенного функцией HeapCreate.</td></tr></TABLE>

</td></tr>
</table>
</center>
<br><br><font color="#0000FF"><a href="index.html">Вернуться к списку тем.</a>

</body>


</html>