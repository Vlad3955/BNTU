<html>

<head>
<title>Методические указания к выполнению курсовых работ по курсу "Системное програмирование"</title>
</head>

<body bgcolor=#F5DEB3 leftmargin="0" topmargin="0" rightmargin="0" bottommargin="0" marginwidth="0">
<center>
<table border="3">
<tr>
<td width="700"> <font color="#0000FF">
<h2><center>7.Обработка исключений (Structured Exception Handling).</center></h2>
<p align="justify">&nbsp&nbsp&nbspРазработать программу, которая демонстрирует генерацию 
различных исключительных ситуаций и различные методы их обработки. Программа должна уметь
порождать и обрабатывать свои собственные исключения.</p>
</td>
<tr>
<td bgcolor="#FFFAFA" width="700"><center><h3><font color="#00008B"></font></h3></center>   

<p align="justify">&nbsp&nbsp&nbspЯзык С представляет программисту ограниченные возможности обработки исключений, возникших при работе программы. В этом отношении С++ намного более развит.
Здесь у программиста существенно большие возможности по непосредственной обработке исключений. Комитет по разработке стандартов С++ предоставил очень 
простую, но мощную форму обработки исключений. <br><br>

Типичная функция, написанная на С, выглядит примерно так: <br><br>
<pre>
 long DoSomething()
{
  long *a, c;
  FILE *b;
  a = malloc(sizeof(long) * 10);
  if (a == NULL)
	return 1;
  b = fopen("something.bah", "rb");
  if (b == NULL) {
	free(a);
	return 2;
  }
  fread(a, sizeof(long), 10, b);

  if (a[0] != 0x10) {
	free(a);
	fclose(b);
	return 3;
  }
  fclose(b);
  c = a[1];
  free(a);
  return c;
}</pre>


<p align="justify">&nbsp&nbsp&nbspВы целиком и полностью зависите от значений, которые возвращают вам функции и для каждой ошибки вам постоянно нужен код, который ее обрабатывает.</p> 

<center><h3>Try-catch-throw</h3></center> 
&nbsp&nbsp&nbspЧтобы комфортно работать с исключениями в С++ вам нужно знать лишь три ключевых слова: <br>
•  try (пытаться) - начало блока исключений; <br>
•  catch (поймать) - начало блока, "ловящего" исключение; <br>
•  throw (бросить) - ключевое слово, "создающее" ("возбуждающее") исключение. <br>

&nbsp&nbsp&nbspА теперь пример, демонстрирующий, как применить то, что вы узнали: <br><br>
<pre>
 void func()
{
  try
  {
    throw 1;
  }
  catch(int a)
  {
    cout << "Caught exception number:  " << a << endl;
    return;
  }
  cout << "No exception detected!" << endl;
  return;
}</pre>

&nbsp&nbsp&nbspЕсли выполнить этот фрагмент кода, то мы получим следующий результат: <br>
 
Caught exception number:  1<br>

&nbsp&nbsp&nbspЕсли закоментировать строку throw 1; функция выдаст такой результат: <br>
No exception detected!
<p align="justify">&nbsp&nbsp&nbspКак видите все очень просто, но если это применить с умом, такой подход покажется вам очень мощным средством обработки ошибок. Catch может "ловить"
любой тип данных, так же как и throw может "кинуть" данные любого типа. Т.е. throw AnyClass(); будет правильно работать, так же как и catch 
(AnyClass &d) {};. 
&nbsp&nbsp&nbspКак уже было сказано, catch может "ловить" данные любого типа, но вовсе не обязательно при это указывать переменную. Т.е. прекрасно будет работать 
что-нибудь типа этого: 
catch(dumbclass) { } 
так же, как и 
catch(dumbclass&) { }. </p>

&nbsp&nbsp&nbspТак же можно "поймать" и все исключения: <br>

catch(...) { }

<p align="justify">&nbsp&nbsp&nbspТроеточие в этом случае показывает, что будут пойманы все исключения. При таком подходе нельзя указать имя переменной. 
В случае, если "кидаются" данные нестандартного типа (экземпляры определенных вами классов, структур и т.д.), лучше "ловить" их по ссылке, иначе 
вся "кидаемая" переменная будет скопирована в стек вместо того, чтобы просто передать указатель на нее. Если кидаются данные нескольких типов и вы 
хотите поймать конкретную переменную (вернее, переменную конкретного типа), то можно использовать несколько блоков catch, ловящих "свой" тип данных: </p>
<pre> 
 try {
       throw 1;
       //  throw 'a';
     }
 catch (long b) {
                  cout << "пойман тип long:  " << b << endl;
                }
 catch (char b) {
                  cout << "пойман тип char:  " << b << endl;
                }
</pre>
 
<center><h3>"Создание" исключений</h3></center> 

<p align="justify">&nbsp&nbsp&nbspКогда возбуждается исключительная ситуация, программа просматривает стек функций до тех пор, пока не находит соответствующий catch. 
Если оператор catch не найден, STL будет обрабатывать исключение в стандартном обработчике, который делает все менее изящно, чем могли бы сделать вы, 
показывая какие-то непонятные (для конечного пользователя) сообщения и обычно аварийно завершая программу. <br>
&nbsp&nbsp&nbspОднако более важным моментом является то, что пока просматривается стек функций, вызываются деструкторы всех локальных классов, 
так что вам не нужно забодиться об освобождении памяти и т.п.</p> 

<center><h3>Операторы throw без параметров</h3></center> 

<p align="justify">&nbsp&nbsp&nbspИтак, мы увидели, как новый метод обработки ошибок удобен и прост.
Блок try-catch может содержать вложенные блоки try-catch и если не будет определено соответствующего оператора catch на текущем уровен вложения, 
исключение будет поймано на более высоком уровне. Единственная вещь, о которой вы должны помнить, - это то, что операторы, следующие за throw, 
никогда не выполнятся. 

<pre>
 try
    {
      throw;
     // ни один оператор, следующий далее (до закрывающей скобки) 
     // выполнен не будет
    }
catch(...)
    {
      cout << "Исключение!" << endl;
    }
</pre>
</p>

</td></tr>
</table>
</center>
<br><br><font color="#0000FF"><a href="index.html">Вернуться к списку тем.</a></font>

</body>


</html>