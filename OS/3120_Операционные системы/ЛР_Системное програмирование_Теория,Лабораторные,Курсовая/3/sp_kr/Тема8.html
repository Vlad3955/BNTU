<html>

<head>
<title>Методические указания к выполнению курсовых работ по курсу "Системное програмирование"</title>
</head>

<body bgcolor=#F5DEB3 leftmargin="0" topmargin="0" rightmargin="0" bottommargin="0" marginwidth="0">
<center>
<table border="3">
<tr>
<td width="700"> <font color="#0000FF">
<h2><center>8.Динамический обмен данными (DDEML).</center></h2>
<p align="justify">&nbsp&nbsp&nbspРазработать DDE-сервер и DDE-клиента для обмена данными, используя горячее связывание.</p>
</td>
<tr>
<td bgcolor="#FFFAFA" width="700"><center><h3><font color="#00008B"></font></h3></center>   


<center><h3>DDE ?</h3></center> 
<p align="justify">&nbsp&nbsp&nbspДавний и прижившийся протокол обмена данными между 
разными приложениями, появившийся еще на заре эры Windows. С тех пор на его базе был создан 
интерфейс OLE, а в 32-разрядном API Windows появились и другие методы межпрограммного 
взаимодействия. Но ниша, занимаемая DDE, осталась неизменной - это оперативная передача и 
синхронизация данных в приложениях.<br>
&nbsp&nbsp&nbspПриложения, использующие DDE, разделяются на две категории - клиенты и 
серверы (не путать с одноименной архитектурой СУБД). Оба участника процесса осуществляют 
контакты (conversations) по определенным темам (topic), при этом в рамках темы производится 
обмен элементами данных (items). Устанавливает контакт клиент, который посылает запрос, 
содержащий имена контакта и темы. После установления контакта всякое изменение элемента 
данных на сервере передается данным клиента.<br>
&nbsp&nbsp&nbspПервоначально программирование DDE было чрезвычайно сложным делом. Оно 
требовало взаимосвязанной обработки более чем десяти сообщений Windows. В версии Windows 
3.1 появилась библиотека DDEML, которая перевела управление DDE на уровень вызова процедур. 
Разработчики подсистемы DDE в Delphi, верные идеологии создания VCL, свели интерфейс этого 
протокола к четырем компонентам: двум для сервера и двум для клиента.<br>
&nbsp&nbsp&nbspНа уровне поддержания контакта лежат компоненты TDDEServerConv и 
TDDEClientConv. Первый играет пассивную роль - он только указывает имя одной из 
поддерживаемых сервером тем. Все операции по установлению и разрыву контакта осуществляет 
из приложения-клиента второй компонент.<br>
&nbsp&nbsp&nbspПосредством одного контакта могут быть связаны и синхронизированы несколько 
пар элементов данных. Для их описания предназначены компоненты TDDEServerItem и 
TDDEClientItem. Каждый из них во время работы должен указывать на контакт, к которому он 
привязан. Кроме того, в составе обоих есть свойства, содержащие некий текст. 
При установленном контакте их содержимое синхронизируется.<br>
&nbsp&nbsp&nbspПомимо этого в модуле DDEMAN описан и пятый компонент, который управляет всеми связями DDE. </p>
<center><h3>Архитектура "клиент-сервер".</h3></center>
<center><img src="рис.8.1.JPG"><br>Рис 8.1 Взаимодействие между клиентом и сервером</center>
<p align="justify">&nbsp&nbsp&nbspПроцесс передачи запроса серверу можно называть 
транзакцией.<br> 
&nbsp&nbsp&nbspСтрого говоря, транзакция - это совокупность трех действий: посылка запроса, 
выполнение запроса, прием ответа.</p>

<center><h3>Инициализация и создание канала связи</h3></center>
&nbsp&nbsp&nbspВ процессе инициализации сервер должен выполнить такие 
действия:<br> 
<ul>зарегистрировать себя в библиотеке DDEML;<br> 
    зарегистрировать предоставляемый сервис, которым сможет воспользоваться приложение-клиент.</ul>

&nbsp&nbsp&nbspКлиент должен сделать следующее: <br>
<ul>зарегистрировать себя в библиотеке DDEML;<br> 
    создать канал связи с сервером, указав необходимый сервис.</ul> 
&nbsp&nbsp&nbspРассмотрим эти действия подробнее. 

<center><h4>Регистрация в библиотеке DDEML</h4></center>

<p align="justify">&nbsp&nbsp&nbspЕсли приложение собирается использовать DDEML, оно должно 
зарегистрировать себя в библиотеке DDEML, вызвав специально предназначенную для этого 
функцию с именем DdeInitialize.<br> 
&nbsp&nbsp&nbspПрототип функции DdeInitialize определен в файле ddeml.h (который должен 
быть включен в исходный текст DDEML-приложения наряду с файлом windows.h): </p>

<pre>UINT WINAPI DdeInitialize( 
                 DWORD FAR* pidInst,      // адрес идентификатора приложения 
                 PFNCALLBACK pfnCallback, // адрес функции обратного вызова 
                 DWORD afCmd,             // флаги
                 DWORD ulRes);            // зарезервировано </pre>

<p align="justify">&nbsp&nbsp&nbspФункция DdeInitialize используется в процессе инициализации и серверов, и 
клиентов DDEML. Сама по себе она не создает никаких каналов передачи данных между 
приложениями, однако процедура регистрации приложения, выполняемая этой функцией, должна 
быть проведена до вызова любых других функций, имеющих отношение к DDEML.</p> 

&nbsp&nbsp&nbspЗаймемся параметрами функции DdeInitialize.<br> 
<p align="justify">&nbsp&nbsp&nbspПараметр pidInst представляет собой указатель на двойное слово, в которое 
после регистрации будет записан идентификатор, присвоенный копии приложения библиотекой 
DDEML (одновременно могут работать несколько копий одного и того же DDEML-приложения). 
Иными словами, в процессе регистрации библиотека DDEML присваивает копии приложения 
некоторый идентификатор, под которым она его "знает". Вы должны указывать полученный от 
функции идентификатор при вызове всех остальных функций библиотеки DDEML.<br> 

&nbsp&nbsp&nbspПеред вызовом функции DdeInitialize ваше приложение должно записать в двойное слово, 
адрес которого передается через первый параметр, нулевое значение. <br>

&nbsp&nbsp&nbspЗаметим, что идентификатор копии приложения, присвоенный в процессе 
регистрации, и идентификатор копии приложения, полученный через параметр функции 
WinMain - разные по смыслу (и по значению) идентификаторы.<br>
 
&nbsp&nbsp&nbspПараметр pfnCallback представляет собой указатель на функцию обратного 
вызова, определенную приложением для обработки транзакций. Как сервер, так и клиент 
должны определить такую функцию. Функция обратного вызова вызывается системой DDEML и 
содержит в себе всю логику обработки транзакций, определенную вами при разработке 
приложения.<br>
 
&nbsp&nbsp&nbspЕсли приложение вызывает функцию DdeInitialize несколько раз для 
многократной регистрации, каждый раз следует указывать отдельную функцию обратного вызова. 
Многократная регистрация вполне допустима, так как каждый раз библиотека DDEML будет 
создавать для себя новый идентификатор приложения. Такая методика используется при создании 
DLL-библиотек, работающих с DDEML. Обычным приложениям достаточно зарегистрировать себя 
один раз и, соответственно, определить одну функцию обратного вызова.<br>
 
&nbsp&nbsp&nbspЧерез параметр afCmd передается двойное слово, каждый бит которого является 
флагом, определяющим режимы работы канала связи, а также влияющие на действия, выполняемые 
функцией DdeInitialize.<br> 

&nbsp&nbsp&nbspПоследний параметр с именем ulRes зарезервирован и должен иметь нулевое 
значение.<br> 

&nbsp&nbsp&nbspПриведем фрагмент кода, выполняющего регистрацию сервера в библиотеке DDEML:</p> 

<pre>idInst = 0L;
     lpDdeSrProc = 
        MakeProcInstance((FARPROC)DDEServerCallback, hInst);
     if(DdeInitialize((LPDWORD)&idInst, (PFNCALLBACK)lpDdeSrProc,
        APPCLASS_STANDARD, 0L))
     {
        return FALSE;
     }</pre>
<p align="justify">&nbsp&nbsp&nbspВ этом фрагменте вначале создается переходник для 
функции обратного вызова, затем адрес этого переходника указывается во втором параметре 
функции DdeInitialize.<br> 
&nbsp&nbsp&nbspВ случае успеха функция DdeInitialize возвращает нулевое значение. Для 
проверки можно также использовать константу DMLERR_NO_ERROR, определенную в файле ddeml.h. 
Если произошла ошибка, возвращается ненулевой код ошибки. Соответствующие константы 
определены в файле ddeml.h и имеют префикс имени DMLERR.<br> 

&nbsp&nbsp&nbspНемного о флагах, передаваемых через параметр afCmd.<br> 

&nbsp&nbsp&nbspСимволические константы с префиксом имени APPCLASS позволяют задать класс 
приложения с точки зрения использования DDEML.<br> 

&nbsp&nbsp&nbspКласс APPCLASS_STANDARD предназначен для регистрации стандартного 
DDEML-приложения. Этот класс использован в приведенном выше фрагменте кода.<br>
 
&nbsp&nbsp&nbspКласс APPCLASS_MONITOR предназначен для отладчиков и других приложений, 
управляющих работой системы DDEML.<br>
 
&nbsp&nbsp&nbspСимволические константы с префиксом имени APPCMD позволяют конкретизировать
функции, выполняемые приложением, и экономить системные ресурсы. Если DDEML-приложение 
выполняет только функции клиента, следует указать флаг APPCMD_CLIENTONLY:</p>
 
<pre>if(DdeInitialize((LPDWORD)&idInst, (PFNCALLBACK)lpDdeClProc,
          APPCMD_CLIENTONLY, 0L))
     {
          return NULL;
     }</pre>
<p align="justify">&nbsp&nbsp&nbspВ простейших случаях можно ограничиться использованием 
класса APPCLASS_STANDARD при создании сервера DDEML и флага APPCMD_CLIENTONLY при создании 
клиента DDEML. Остальные флаги влияют на то, когда и зачем будет вызываться функция 
обратного вызова.<br> 

&nbsp&nbsp&nbspЕсли приложение больше не собирается работать с библиотекой DDEML, оно 
должно вызвать функцию DdeUninitialize, передав ей в качестве единственного параметра 
идентификатор копии приложения, полученный от функции DdeInitialize:<br> 

BOOL WINAPI DdeUninitialize(DWORD idInst);</p>

<center><h4>Регистрация сервиса</h4></center>

<p align="justify">&nbsp&nbsp&nbspСледующий этап в инициализации сервера DDEML заключается 
в регистрации предоставляемого им сервиса.<br>
 
&nbsp&nbsp&nbspБиблиотека DDEML использует трехступенчатую схему адресации данных, 
передаваемых по каналу связи - сервис (service), раздел (topic) и элемент данных 
(data item). Приложение задает элементы адреса в виде текстовых строк размером не более 
255 байт.<br>

&nbsp&nbsp&nbspСервер DDEML может предоставлять сервис одного или нескольких видов. 
Как правило, один сервер предоставляет только один сервис, причем текстовая строка, 
идентифицирующая сервис, часто совпадает с именем приложения. Но можно выбрать любую 
другую строку.<br>
 
&nbsp&nbsp&nbspВторой элемент адреса - раздел. В рамках одного сервиса можно определить 
несколько разделов. Когда клиент DDEML создает канал с сервером, он указывает сервис и 
раздел. Раздел объединяет группу элементов данных или выполняемых функций.<br>
 
&nbsp&nbsp&nbspКанал DDEML служит для передачи блоков данных. В рамках одного раздела 
сервер может обмениваться с клиентом разными блоками данных, каждый из которых 
идентифицируется при передаче именем элемента данных. В процессе создания канала 
связи не требуется указывать элементы данных.<br> 

&nbsp&nbsp&nbspРегистрация сервиса выполняется сервером DDEML обычно сразу после вызова 
функции DdeInitialize и выполняется в два этапа.<br>
 
&nbsp&nbsp&nbspНа первом этапе текстовая строка имени сервиса сохраняется в специальной 
системной таблице (таблице атомов), для чего вызывается функция DdeCreateStringHandle:</p> 

<pre>HSZ WINAPI DdeCreateStringHandle(
                        DWORD idInst,   // идентификатор приложения
                        LPCSTR psz,     // адрес текстовой строки
                        int iCodePage); // кодовая страница</pre>

<p align="justify">&nbsp&nbsp&nbspЧерез параметр idInst приложение должно передать 
идентификатор, полученный на этапе регистрации приложения в библиотеке DDEML функцией 
DdeInitialize.<br>
 
&nbsp&nbsp&nbspПараметр psz представляет собой указатель на текстовую строку, 
закрытую двоичным нулем. Размер этой строки не должен превышать 255 байт.<br>
 
&nbsp&nbsp&nbspВ качестве значения для параметра iCodePage можно указать CP_WINANSI 
(эта константа равна нулю). Можно также использовать значение, полученное от функции 
GetKBCodePage. Функция GetKBCodePage не имеет параметров и возвращает номер текущей 
кодовой страницы.<br>
 
&nbsp&nbsp&nbspИдентификатор текстовой строки, возвращенный функцией DdeCreateStringHandle 
и соответствующий регистрируемому сервису, следует передать функции DdeNameService:</p>
 
<pre>HDDEDATA WINAPI DdeNameService(
                         DWORD idInst, // идентификатор приложения
                         HSZ hsz1,     // идентификатор строки имени сервиса
                         HSZ hsz2,     // зарезервировано
                         UINT afCmd);  // флаги</pre>

<p align="justify">&nbsp&nbsp&nbspЧерез параметр idInst приложение должно передать 
идентификатор, полученный на этапе регистрации приложения в библиотеке DDEML функцией 
DdeInitialize.<br>
 
&nbsp&nbsp&nbspПараметр hsz1 предназначен для передачи имени сервиса через идентификатор 
текстовой строки, возвращенной функцией DdeCreateStringHandle.<br>
 
&nbsp&nbsp&nbspПараметр hsz2 зарезервирован, для него следует использовать нулевое 
значение.<br>
 
&nbsp&nbsp&nbspПри регистрации сервиса через параметр afCmd следует передать значение 
DNS_REGISTER (регистрация сервиса). Сервер DDEML в процессе своей работы может динамически 
регистрировать и отменять виды предоставляемого сервиса. Для отмены сервиса через параметр 
afCmd передается значение DNS_UNREGISTER.<br>
 
&nbsp&nbsp&nbspПеред завершением работы сервер DDEML должен отменить весь зарегистрированный
им ранее сервис, вызвав функцию DdeInitialize с параметром afCmd, имеющим значение 
DNS_UNREGISTER.<br>
 
&nbsp&nbsp&nbspЕсли регистрация сервиса выполнена успешно, функция DdeNameService 
возвращает ненулевое значение, а при ошибке - нулевое.<br> 

&nbsp&nbsp&nbspОдновременно с регистрацией сервиса сервер обычно создает идентификаторы 
текстовых строк, содержащих имена используемых разделов и элементов данных. Для этого 
вызывается все та же функция DdeCreateStringHandle.<br> 

&nbsp&nbsp&nbspОтметим, что регистрацию сервиса выполняет только сервер DDEML. 
Что же касается создания идентификаторов текстовых строк функцией DdeCreateStringHandle, 
то эта операция выполняется как сервером, так и клиентом. Полученные идентификаторы 
используются при создании канала и в процессе передачи данных.<br> 

&nbsp&nbsp&nbspЗная идентификатор строки, приложение может получить строку, 
вызвав функцию DdeQueryString:</p> 

<pre>DWORD WINAPI DdeQueryString(
                    DWORD idInst,   // идентификатор приложения
                    HSZ hsz,        // идентификатор строки
                    LPSTR psz,      // адрес буфера для записи строки
                    DWORD cchMax,   // размер буфера
                    int iCodePage); // кодовая страница</pre>

<p align="justify">&nbsp&nbsp&nbspНазначение параметров понятно из комментариев в прототипе 
функции.<br>
 
&nbsp&nbsp&nbspЕсли идентификатор созданной текстовой строки используется в функции 
обратного вызова (которую мы рассмотрим чуть позже), за освобождение ресурсов, связанных 
с текстовой строкой, отвечает система DDEML. В противном случае приложение должно 
самостоятельно уничтожать созданные им идентификаторы, вызывая функцию 
DdeFreeStringHandle:</p> 

<pre>BOOL WINAPI DdeFreeStringHandle(
                        DWORD idInst, // идентификатор приложения
                        HSZ hsz);     // идентификатор уничтожаемой строки</pre>

<p align="justify">&nbsp&nbsp&nbspВ случае успеха функция DdeFreeStringHandle возвращает ненулевое значение, при 
ошибке - нулевое.</p>


<center><h4>Функция обратного вызова DDEML</h4></center>

<p align="justify">&nbsp&nbsp&nbspКогда сервер или клиент регистрирует себя в библиотеке DDEML при 
помощи функции DdeInitialize, он указывает адрес переходника, созданного для функции 
обратного вызова. Функция обратного вызова предназначена для обработки всех событий, 
возникающих в процессе создания каналов связи и передачи данных.<br>

&nbsp&nbsp&nbspВ простейшем случае функция обратного вызова сервера DDEML может 
выглядеть следующим образом:</p>
 
<pre>HDDEDATA EXPENTRY _export DDEServerCallback(
            WORD wType,     // код транзакции
            WORD wFmt,      // формат данных
            HCONV hConv,    // идентификатор канала
            HSZ hsz1,       // первый идентификатор строки
            HSZ hsz2,       // второй идентификатор строки
            HDDEDATA hData, // идентификатор глобальной области данных
            DWORD dwData1,  // первое дополнительное двойное слово
            DWORD dwData2)  // второе дополнительное двойное слово
{
   switch(wType)
   {
      // Создание канала передачи данных
      case XTYP_CONNECT:
      {
        ...........
        return((HDDEDATA)TRUE);
      }

      // Запрос данных от сервера
      case XTYP_REQUEST:
      {
        ...........
        return(hData);
      }

      // Запрос на выполнение команды
      case XTYP_EXECUTE:
        ...........
        break;

      // Передача данных серверу
      case XTYP_POKE:
      {
        ...........
        return((HDDEDATA)DDE_FACK);
      }

      // Подтверждение создания канала
      case XTYP_CONNECT_CONFIRM:
      {
        ...........
        break;
      }

      // Завершение работы канала
      case XTYP_DISCONNECT:
      {
        ...........
        break;
      }

      // Ошибка
      case XTYP_ERROR:
      {
        ...........
        break;
      }
   }
   return((HDDEDATA)NULL);
}</pre>

<p align="justify">&nbsp&nbsp&nbspФункция обратного вызова должна быть определена как 
экспортируемая, поэтому мы указали ключевое слово _export.<br>
 
&nbsp&nbsp&nbspЧерез первый параметр wType передается код транзакции. Подобно функции 
окна, которая обрабатывает сообщения, функция обратного вызова DDEML выполняет обработку 
транзакций. В зависимости от кода транзакции и результата обработки функция обратного 
вызова DDEML возвращает то или иное значение.<br>
 
&nbsp&nbsp&nbspВторой параметр задает код формата передаваемых данных. Для кодов формата 
используются те же значения, что и для форматов Clipboard, например, CF_TEXT. 
Через параметр hConv передается идентификатор канала передачи данных .<br>

&nbsp&nbsp&nbspНазначение остальных параметров функции обратного вызова зависит от кода 
транзакции. В приведенном выше фрагменте кода используются символические имена кодов 
транзакций, определенные в файле ddeml.h, и имеющие префикс имени XTYP.<br>

&nbsp&nbsp&nbspФункция обратного вызова для клиента DDEML выглядит точно также, 
отличаясь лишь составом обрабатываемых транзакций.<br>
 
&nbsp&nbsp&nbspПри регистрации приложения в библиотеке DDEML функцией DdeInitialize 
можно указать флаги, запрещающие или разрешающие поступление транзакций некоторых типов в 
функцию обратного вызова. Запретив вызов функции обратного вызова для необрабатываемых 
транзакций, можно ускорить работу приложения.</p>


<center><h4>Создание и уничтожение канала</h4></center> 

<p align="justify">&nbsp&nbsp&nbspПоследнее, что нужно сделать перед началом передачи 
данных по каналу DDEML, - создать канал связи (conversation).<br>
 
&nbsp&nbsp&nbspКанал связи между клиентом и сервером создается всегда по инициативе 
клиента. После регистрации в библиотеке DDEML клиент вызывает функцию DdeConnect, 
создающую канал связи:</p> 

<pre>HCONV WINAPI DdeConnect(
       DWORD idInst,          // идентификатор приложения
       HSZ hszService,        // идентификатор строки сервиса
       HSZ hszTopic,          // идентификатор строки раздела
       CONVCONTEXT FAR* pCC); // адрес данных контекста</pre>

<p align="justify">&nbsp&nbsp&nbspЧерез параметр idInst приложение должно передать 
идентификатор, полученный на этапе регистрации приложения в библиотеки DDEML функцией 
DdeInitialize.<br>
 
&nbsp&nbsp&nbspПараметры hszService и hszTopic предназначены для передачи идентификаторов 
строк, содержащих, соответственно, имена сервиса и раздела. Эти идентификаторы были 
получены нами ранее при помощи функции DdeCreateStringHandle.<br>
 
&nbsp&nbsp&nbspПоследний параметр - указатель на структуру типа CONVCONTEXT. 
Эта структура используется для указания информации о национальном языке и кодовой 
странице, соответствующей передаваемым данным. В простейшем случае для данного параметра 
можно указать значение NULL, при этом будет использована кодовая страница CP_WINANSI 
(что приемлемо в подавляющем большинстве случаев).<br>
 
&nbsp&nbsp&nbspИдентификатор канала, полученный от функции DdeConnect, следует сохранить 
для обеспечения возможности получения данных от сервера.<br>
 
&nbsp&nbsp&nbspЧто же происходит, когда клиент создает канал, вызывая функцию DdeConnect?<br>
 
&nbsp&nbsp&nbspПрежде всего, библиотека DDEML посылает транзакцию с кодом XTYP_CONNECT 
всем активным серверам, которые зарегистрировали сервис, указанный во втором параметре 
функции DdeConnect.<br>
 
&nbsp&nbsp&nbspДля транзакции XTYP_CO                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             