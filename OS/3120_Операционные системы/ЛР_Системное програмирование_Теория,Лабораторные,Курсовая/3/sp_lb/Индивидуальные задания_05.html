<html>
<head>
<title>Задания к лабораторной работе № 5</title>
<link href=style.css rel=stylesheet type=text/css>
</head>
<body>
<div class="title"><A name=REF_1_C></A>Задания к лабораторной работе № 5</div><br>
<p>
Условием выполнения данной работы является выполненная предыдущая работа.
<br>Для всех вариантов необходимо выполнить следующее:
<ul>
	<li>определить функции в соответствии с вариантом задания;
	<li>в функции main() реализовать демонстрацию работы созданных функций;
Во всех заданиях необходимо использовать функции Win32 API для работы с файлами.
</p>

<div class="header">Варианты заданий</div>
<p>
<b>Вариант №1</b>	
<BR>Определить две функции:
<ul>
	<i>void WriteDate(char * fname, Date * buffer, int count)</i>; – функция записывает <i>count</i> элементов типа <i>Date</i> из массива <i>buffer</i> в файл с именем <i>fname</i>;
	<br><i>int ReadDate(char * fname, Date * buffer, int count)</i>; – функция читает <i>count</i> элементов типа <i>Date</i> из файла с именем <i>fname</i> в массив <i>buffer</i> и возвращает количество фактически прочитанных элементов.
</ul>

<br><br><b>Вариант №2</b>	
<br>Определить две функции:
<ul>
	<i>void WriteTime(char * fname, Time * buffer, int count)</i>; – функция записывает <i>count</i> элементов типа <i>Time</i> из массива <i>buffer</i> в файл с именем <i>fname</i>;
	<br><i>int ReadTime(char * fname, Time * buffer, int count)</i>; – функция читает <i>count</i> элементов типа <i>Time</i> из файла с именем <i>fname</i> в массив <i>buffer</i> и возвращает количество фактически прочитанных элементов.
</ul>

<br><br><b>Вариант №3</b>
<br>Определите следующие функции:
<ul>
	<i>void WriteTree(char * fname, Node * node)</i>; – функция записывает бинарное дерево с корневым элементом <i>node</i> в файл с именем <i>fname</i>. Для записи отдельного узла имеет смысл определить специальную функцию:
<br><i>void WriteNode(HANDLE hf, Node * node)</i>;
<br>Алгоритм этой функции аналогичен алгоритму вывода дерева на экран, но выполнять она будет следующие действия (обход узлов дерева начинается слева):
<ul>
	<li>если node == 0, то записать в файл значение 0 (int) и выйти из функции;
	<br><li>иначе определить количество символов (count) в имени узла;
	<br><li>записать в файл count и имя узла (count символов из поля name);
	<br><li>вызвать функцию WriteNode для всех ветвей узла.
</ul>
<i>Node * ReadTree(char * fname)</i>; – функция создает из файла с именем <i>fname</i> бинарное дерево. Функция возвращает указатель на корневой узел. Для чтения отдельного узла можно определить специальную функцию
<br><i>Node * ReadNode(HANDLE hf)</i>;
<br>Алгоритм функции может быть следующим:
<ul>
	<li>прочитать значение типа int в переменную count;
	<br><li>если count != 0, то прочитать count символов в массив name; создать узел с именем name и для каждой его ветви вызвать функцию ReadNode; возвратить указатель на созданный узел;
	<br><li>иначе возвратить 0.
</ul>
</ul>

<br><br><b>Вариант №4</b>
<br>Определите следующие функции:
<ul>
	<i>void WriteList(char * fname, List * plst)</i>; – функция записывает элементы списка в файл;
	<br><i>List * ReadList(char * fname)</i>; – функция читает значения элементов из файла и создает список;
</ul>

<br><br><b>Вариант №5</b>
<br>Определите следующие функции:
<ul>
	<i>void WriteStack(char * fname, Stack * pstk)</i>; – функция записывает элементы стека в файл;
	<br><i>Stack * ReadStack(char * fname)</i>; – функция читает значения элементов из файла и создает стек;
</ul>

<br><br><b>Вариант №6</b>
<br>Определить функцию:
<ul>
	<i>Node * CreateBalansedTree(char * fname)</i>; – функция создает сбалансированное бинарное дерево. Функция вначале открывает файл, читает первую строку (имя узла) и создает корневой узел. Далее для всех оставшихся строк из файла вызывает функцию:
<br><i>void AddNode(Node * node, char * name)</i>;
<br>Функция AddNode() должна выполнять следующие действия:
<ul>
	<li>если у узла нет дочерних узлов слева/справа, то добавить слева/справа новый узел;
	<br><li>иначе выбрать дочерний узел, у которого высота меньше (а если высоты равны то выбрать левый) и вызвать функцию <i>AddNode()</i> для выбранного узла.
</ul>
</ul>

<br><br><b>Вариант №7</b>
<br>Определите следующие функции:
<ul>
	<i>void WriteQueue(char * fname, Queue * pque)</i>; – функция записывает элементы очереди в файл;
	<br><i>Queue * ReadQueue(char * fname)<i>; – функция читает значения элементов из файла и создает очередь
</ul>

<br><br><b>Вариант №8</b>
<br>Определить две функции:
<ul>
	<i>void WriteComplex(char * fname, Complex * buffer, int count)</i>; – функция записывает count элементов типа <i>Complex</i> из массива <i>buffer</i> в файл с именем <i>fname</i>;
	<br><i>int ReadComplex(char * fname, Complex * buffer, int count)</i>; – функция читает <i>count</i> элементов типа <i>Complex</i> из файла с именем <i>fname</i> в массив <i>buffer</i> и возвращает количество фактически прочитанных элементов.
</ul>

<br><br><b>Вариант №9</b>
<br>Определить две функции:
<ul>
	<i>void WriteTree(char * fname, Node * node)</i>; – функция записи дерева в файл.
	<br><i>Node * ReadTree(char * fname)</i>; – функция чтения дерева из файла.
</ul>

<br><br><b>Вариант №10</b>
<br>Определить две функции:
<ul>
	<i>void WritePairs(char * fname, Pairs * prs)</i>; – функция записывает все элементы типа <i>Pair</i> из массива пар <i>prs</i> в файл с именем <i>fname</i>;
	<br><i>void ReadPairs(char * fname, Pairs * prs)</i>; – функция читает все элементы типа <i>Pair</i> из файла с именем <i>fname</i> в массив пар <i>prs</i>.
</ul>
</p>

