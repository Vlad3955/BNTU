<html>
<head>
<title>Задания к лабораторной работе № 7</title>
<link href=style.css rel=stylesheet type=text/css>
</head>
<body>
<div class="title"><A name=REF_1_C></A>Задания к лабораторной работе № 7</div><br>
<p>
Данная работа выполняется на основе предыдущих лабораторных работ №4-6.
</p>

<div class="header">Варианты заданий</div>
<p>
<b>Вариант №1</b>	
<BR>Имеется массив элементов типа Date в виде структуры
<ul>
	struct Dates
	<br>{
	<br>int count = 0;//количество имеющихся элементов в массиве
	<br>Date dates[100];
	<br>} dts = {0};
</ul>
Главный поток программы (функция <i>main()</i>) создает вторичный поток, передав в него указатель на <i>структуру dts</i>.
<br>Вторичный поток запоминает значение из поля <i>count</i>, открывает файл и затем в цикле, если значение <i>count</i> изменилось, то записывает последний элемент массива <i>dates</i> в файл. Так продолжается до тех пор, пока <i>count</i> не достигнет некоторого максимального значения, после этого поток закрывает файл и завершается;
<br>Далее главный поток организует цикл ввода дат следующим образом:
<ul>
	<li>инициализируется временная переменная tmp типа Date (ввод с клавиатуры);
	<br><li>с помощью функции SuspendThread() приостанавливается поток;
	<br><li>значение временной переменной заносится в массив
	<br>dts.dates[dts.count] = tmp;
	<br>dts.count++;
	<br><li>с помощью функции ResumeTread() поток запускается на выполнение;
</ul>
Так продолжается до тех пор, пока <i>count</i> не достигнет некоторого максимального значения.

<br><br><b>Вариант №2</b>	
<br>Главный поток программы создает вторичный поток, в который передает указатель на глобальную переменную типа <i>Time</i>. 
<br>Поток вычисляет количество секунд пошедших от начала суток до указанного времени и выводит на экран. Затем запоминает время и в последующем вычисляет разницу между новым и старым значениями. Так продолжается до тех пор, пока не будет передано время 00:00:00, после этого поток завершается.
<br>Главный поток в цикле вводит с клавиатуры значение времени во временную переменную tmp, с помощью функции <i>SuspendThread()</i> приостанавливает поток, записывает введенное значение в глобальную переменную и затем с помощью функции <i>ResumeTread()</i> запускает поток на выполнение. Завершение цикла – ввод значения 00:00:00.

<br><br><b>Вариант №3</b>
<br>Функция записи узла дерева в файл <i>(WriteNode())</i> выполняется во вторичном потоке. При создании потоку передается указатель на переменную типа <i>Node*</i>. 
<br>Поток должен записать новый узел в файл если адрес узла изменился.
<br>Главный поток в цикле добавляет узлы в дерево (новые узлы добавляются слева на право). Перед добавлением нового узла поток приостанавливается, а в конце добавления запускается. С помощью программы из 4-й работы проверить правильность записанного в файл дерева.

<br><br><b>Вариант №4</b>
<br>Аналогично как в варианте 3, но для элементов списка.
<br><br><b>Вариант №5</b>
<br>Аналогично как в варианте 4, но для элементов стека.
<br><br><b>Вариант №6</b>
<br>Аналогично как в варианте 3, но вторичный поток проверяет сбалансировано дерево или нет. Необходимо добавить две функции: добавления узла (см. лаб. раб. №4 вариант 3) и поиска узла по его имени (рекурсивная функция аналогичная функции вывода дерева, см. там же).
<br><br><b>Вариант №7</b>
<br>Аналогично как в варианте 5, но для элементов очереди.
<br><br><b>Вариант №8</b>
<br>Аналогично как в варианте 1, но для комплексных чисел.
<br><br><b>Вариант №9</b>
<br>Аналогично как в варианте 3, но для узлов TreeNode.
<br><br><b>Вариант №10</b>
<br>Аналогично как в варианте 1, но для элементов типа Pair.
</p>

