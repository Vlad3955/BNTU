<html>
<head>
<title>ЛАБОРАТОРНАЯ РАБОТА №1</title>
<link href=style.css rel=stylesheet type=text/css>
</head>
<body>
<div class="title"><A name=REF_1_C></A>ЛАБОРАТОРНАЯ РАБОТА №1</div><br>
<div class="title"><A name=REF_1_1_1></A> Обзор языка  программирования С</div>
<p>
<center>[<a href="#0">Оглавление</a>][<a href="index.html">Содержание</a>][<a href="Лабораторная работа №2.html">Следующая работа</a>]</center>
		
<br>
<br>
<div class="title">

<a name="0"></a>Оглавление</div>
		
<ol type="1">
			
<li>
<a href="#1">Цель работы</a>			
</li>
			
<li>		
<a href="#2">Основные сведения о синтаксисе языка C</a>
</li>
			


<li>
<a href="#3">Структура программ на языке С</a>			
</li>





<li>
<a href="#4">Операционные объекты в языке C</a>			
</li>



<li>
<a href="#5">Понятие типа объекта в языке С</a>			
</li>


<li>
<a href="#6">Массивы в языке С</a>			
</li>


<li>
<a href="#7">Операции</a>			
</li>	
<ul>
			
<li>				
<a href="#7_1">Операции присваивания</a>
</li>
			
<li>
<a href="#7_2">Арифметические операции</a>
</li>
			
<li>
<a href="#7_3">Операции отношений</a>
</li>
			
<li>
<a href="#7_4">Логические операции</a>
</li>
			
</ul>

<li>
<a href="#8">Операторы</a>			
</li>
<ul>
			
<li>				
<a href="#8_1">Условные операторы</a>
</li>
			
<li>
<a href="#8_2">Операторы цикла</a>
</li>
			
<li>
<a href="#8_3">Оператор выбора альтернатив (переключатель)</a>
</li>
			
<li>
<a href="#8_4">Операторы передачи управления</a>
</li>
			
</ul>
<li>
<a href="#9">Индивидуальные задания</a>			
</li>

	
</ol>
		
<br>
<br>





<p>
<a name="1"></a>
<div class="header">1. Цель работы</div>
</p>
<div class="header">1.1. Ознакомление с языкот Си.</div>
<div class="header">1.2. Приобретение практических навыков работы с Си</div>

<p>
<a name="2"></a>
<div class="header">2. Основные сведения о синтаксисе языка C </div>

<p>
Начальные сведения о синтаксисе любого языка программирования включают элементарные правила записи исходного текста программы - идентификация объектов программы, комментарии, формат исходного текста.
<br>Идентификаторы объектов программы на языке C могут включать: 
<ul>
	<li>цифры 0...9; 
	<li>латинские прописные и строчные буквы A...Z, a...z; 
	<li>символ подчеркивания _.
</ul>
Первый символ идентификатора не может быть цифрой. Длина идентификатора 
определяется реализацией транслятора C и редактора связей (компоновщика). Современная тенденция - снятие ограничений длины идентификатора. 
<br>Разделители идентификаторов объектов программы: 
<ul>
	<li>пробелы; 
	<li>символы табуляции, перевода строки и страницы; 
	<li>комментарии (играют роль пробелов). 
</ul>
Комментарий - любая последовательность символов, начинающаяся парой символов /* и заканчивающаяся парой символов */. 
<br>Формат записи исходного текста программ на языке C - свободный. 
 </p>

<pre><div class="code">
     /* ПРИМЕР ПРОГРАММЫ ТЕСТА ГЕНЕРАТОРА СЛУЧАЙНЫХ ЧИСЕЛ */
     
     #include <stdio.h>
     #include <stdlib.h>
     
     #define RANGE 100
     
     void main() {
      int i,j,k,s;
     
      /* Запрос объема выборки */

      while (printf("\n K-? "), !scanf(" %d",&k);

      /* Генерация случайных чисел */

      printf("\n Значения %d случайных чисел:\n",k);
      for (s=i=0; i < k; i++) 
       s+=(j=random(RANGE)+1);
       printf("\n %3d) %d",i,j);
      }
      printf("\n\n Сумма %d, среднее %f",s,(float)s/k);
     }
</div></pre>


<a name="3"></a>
<div class="header">3. Структура программ на языке С </div>
<p>
Программа на языке С включает операторы декларации объектов, преобразования объектов и управления вычислительным процессом. Программирование процесса преобразования объектов программы производится посредством записи выражений. Выражение включает один или несколько операндов и символов операций. Любое выражение, заканчивающееся символом ';', является оператором. 
<br>Простейший вид операторов - операторы-выражения: 
<ul>
	<li>оператор присваивания - выполнение операций присваивания; 
	<li>оператор вызова функции - операция вызова функции; 
	<li>пустой оператор. 
</ul>
Классы управляющих операторов в языке С: 
<ul>
	<li>операторы условного и безусловного перехода; 
	<li>операторы организации циклов; 
	<li>оператор выбора альтернатив (переключатель); 
	<li>оператор выхода из функции. 
</ul>
Каждый из управляющих операторов имеет конкретную лексическую конструкцию, образуемую из ключевых слов языка С, выражений и символов-разделителей <b>'{','}',',',':','(',')'</b>. <br>Операторы языка С записываются в свободном формате с использованием разделителей между ключевыми словами. 
<br>Допустима вложенность операторов. Любой оператор может помечаться меткой - идентификатором и символом <b>':'</b>. Область действия метки - функция, где эта метка определена. В случае необходимости можно использовать составной оператор (блок) - последовательность любых операторов, заключенная в фигурные скобки { и } (после закрывающей скобки символ <b>';' </b>не требуется). Элементарным модулем программы на языке С является функция. Любая программа должна содержать, как минимум, головную функцию со стандартным именем <b>main</b>. 
<br>Пример исходного текста программы:
</p>

<pre><div class="code">
     #include <stdio.h>
     
     /* ПРОГРАММА ПЕЧАТИ КОДОВ НАЖАТЫХ КЛАВИШ */
     
     void main () {
      int i;
      
      while ((i=getch())!=27) {
      if (i==0) printf("\n* %d",getch());
       else printf("\n  %d",i);
      }
     }
</div></pre>

<a name="4"></a>
<div class="header">4. Операционные объекты в языке C </div>

<p>
Классы операционных объектов программ на языке C: 
<ul>
	<li>константы; 
	<li>простые переменные; 
	<li>массивы; 
	<li>структуры; 
	<li>объединения; 
	<li>указатели объектов; 
	<li>функции. 
</ul>
Объекты программы в общем случае имеют атрибуты:
<ul> 
	<li>тип - характеристика механизма интерпретации данных; 
	<li>класс памяти - характеристика способа организации размещения объектов в памяти (статическая и динамическая память); 
	<li>область действия - характеристика области использования объектов функциями программы (локальные и глобальные объекты).
</ul> 
Единственная разновидность объектов, определяемая в исходном тексте непосредственно по месту использования - константы. Иногда используют термин "самоопределенные константы". Остальные объекты программы должны быть явно описаны в виде 
<br><атрибуты> <список_идентификаторов_объектов>; 
<br>(элементы списка разделены запятыми, а атрибуты - разделителями). 
<br>Предварительно отметим следующее: 
<ul>
	<li>в языке C атрибуты типа описываются всегда явно; 
	<li>класс памяти можно не указывать, используя назначение по умолчанию; 
	<li>область действия объекта специальным ключевым словом не задается. 
</ul>
</p>
<a name="5"></a>
<div class="header">5. Понятие типа объекта в языке С </div>

<p>
Тип объекта рекурсивно определяется на основе любого базового и производного типа посредством использования: 
<ul>
	<li>символов модификации текущего типа; 
	<li>предписания размещения объектов известных типов в памяти.
</ul> 
Модификаторы текущего типа: 
<ul>
	<li>символ * перед идентификатором - описание указателя на объект исходного типа; 
	<li>символы [ и ] после идентификатора объекта - описание массива объектов; 
	<li>символы ( и ) после идентификатора объекта - описание функции. 
</ul>
Отметим, что обязательное условие использования скобочных модификаторов любого вида - баланс открывающих и закрывающих скобок. Внутри скобок может размещаться детализирующая описание типа информация, например, размерность массива или список параметров. 
<br>Допускается использование более одного модификатора типа c учетом следующих правил:
<ul> 
	<li>чем ближе модификатор к идентификатору, тем выше его приоритет; 
	<li>модификаторы [] и () обладают приоритетом перед *; 
	<li>дополнительно вводимые круглые скобки позволяют увеличить приоритет объединяемых ими элементов описания.
</ul> 
Примеры описания объектов: 
</p>

<pre><div class="code">
type a0;        /* Элемент типа type */
type a1[5];     /* Массив элементов типа type */
type *a2;       /* Указатель на элемент типа type */
type **a3;      /* Указатель на указатель элемента типа type */
type *a4[5];    /* Массив указателей на элементы типа type */
type (*a5)[10]; /* указатель на массив элементов типа type */
type *a6[3][4]; /* 3-элементный массив указателей
                   на 4-элементный массив элементов типа type */
type a7[5][2];  /* Массив массивов элементов типа type */
type a8();      /* Функция, вычисляющая значение типа type */
type *a9();     /* Функция, вычисляющая указатель
                   на элемент типа type */
type (*aa)();   /* Указатель на функцию, вычисляющую
                   значение типа type */
type *ab()[6];  /* Функция, вычисляющая указатель
                   на массив элементов типа type */
type *aс[4]();  /* Массив указателей на функцию, вычисляющую
                   значение типа type */
</div></pre>

<p>
Здесь <b>type</b> - некоторый известный текущий тип объектов. Возможности определения размещения объектов известных типов в памяти в языке C представлены понятиями массивов, структур и объединений (см. 2.4-2.5).
</p>
<a name="6"></a>
<div class="header">6. Массивы в языке С </div>
<p>
Массив - простейший вид структурного типа, представляющий поименованную совокупность последовательно размещаемых в памяти данных одного типа. Примеры описания массивов:
</p>
<pre><div class="code">
     char s[20];       /* Одномерный массив */
     int  x[10][20];   /* Двумерный массив  - массив массивов */
</div></pre>
<p>
Особенность индексации элементов массива в языке C - нулевой индекс первого элемента по каждому измерению. Доступ к отдельному элементу массива выполняется после указания его целочисленного индекса двумя способами: использование операции индексации - s[10], x[5][6]; косвенное обращение по указателю - *(s+10), *(*(x+5)+6). 
</p>

<a name="7"></a>
<div class="header">7. Операции  </div>
<p>
<a name="7_1"></a>
<div class="header">7.1 Операции присваивания </div>
</p>
<p>
Присваивание значения в языке C в отличие от традиционной интерпретации 
<br>идентификатор=выражение; 
<br>рассматривается как выражение, имеющее значение левого операнда после присваивания. Оператор присваивания, таким образом, может включать несколько операций присваивания и, как следствие, изменить значения нескольких операндов как побочный результат вычисления выражения:
</p>

<pre><div class="code">
     int i,j,k;
     float x,y,z;
     char a,b;
     ...
     x=i+(y=3)-(z=0);  <===>  z=0; y=3; x=i+y-z;
     i=j=k=0;          <===>  k=0; j=k; i=j;
     a=(i+b);          <===>  a=i+b; /* Результат - ? */
</div></pre>

<p>
Очевидно, что в случае использования в выражении неодинаковых операций или разнотипных операндов возникают вопросы: 
<ul>
	<li>порядок выполнения операций в выражении; 
	<li>последовательность вычисления операндов; 
	<li>корректность преобразования операндов. 
</ul>
Предварительные ответы: 
<ul>
	<li>порядок выполнения операций можно определять круглыми скобками и(или) учитывать их приоритет, а в случае одинакового приоритета - направление выполнения каждой операции; 
	<li>последовательность вычисления операндов большинства операций стандартом языка С не регламентирована, а для коммутативных операций может оптимизироваться компилятором даже при наличии круглых скобок; 
	<li>корректность преобразования операндов гарантируется в рамках реальных аппаратных возможностей, подозрительные ситуации стремится обнаружить компилятор, а любые неопределенности устраняются явным использованием операции приведения типа.
</ul>
<br>Таким образом, конструирование выражений в языке С следует проводить с нетрадиционной для языков высокого уровня осторожностью. Из выделенных понятий только приоритет и направление выполнения операций стандартны в языке С, а остальные в общем случае являются системно зависимыми. 
<br>Традиционная форма операции присваивания 
<br>v = e 
<br>(здесь v - операнд-переменная, e - выражение). В языке C допускается две разновидности сокращений записи операции присваивания: 
<br><br>1) вместо записи 
<br>v = v operator_ab e 
<br>рекомендуется использовать запись 
<br>v operator_ab = e 
<br><br>(здесь operator_ab - арифметическая операция либо операция над битовым представлением операндов); 
<br><br>2) вместо записи 
<br>ipv = ipv + 1 
<br>либо 
<br>ipv = ipv - 1 
<br>рекомендуется использовать запись 
<br>ipv++ либо ipv--, 
<br>а также 
<br>++ipv либо --ipv 
<br><br>(здесь cимвол '+' обозначает операцию инкремента, cимвол '-' операцию декремента, ipv - целочисленная переменная или переменная - указатель). 
<br>Значением выражения ++x или --x является значение x после операции инкремента или декремента, а значением выражения x++ или x-- - значение x до операции (подробности операций над указателями см. ниже). Примеры использования сокращений:
</p>


<pre><div class="code">
     int i,j,k;
     float x,y;
     ...


     x*=y;     <===>  x=x*y;
     i+=2;     <===>  i=i+2;
     x/=y+15;  <===>  x=x/(y+15);
     k--;      <===>  k=k-1;
     --k;      <===>  k=k-1;
     j=i++;    <===>  j=i; i=i+1;
     j=--i;    <===>  i=i-1; j=i;

</div></pre>

<p>
Рекомендации использования сокращений обоснованы возможностью оптимизации программы. <br>Например, схема выражения вида 
<br>v operator_ab = e 
<br>соответствует схеме выполнения многих машинных команд типа "регистр-память". Ограничения на целочисленность операндов операций вида ++ipv (--ipv) или ipv++ (ipv--) следуют из наличия машинных команд инкремента и декремента целочисленных операндов. Отметим, что левым операндом операции присваивания может быть только именованная либо косвенно адресуемая указателем переменная (в диагностических сообщения компилятора - LVALUE). 
<br>Примеры недопустимых выражений: 
<br><br>а) присваивание константе: 
<br>2=x+y getch()=i z=&y /* z - имя массива */ 
<br><br>б) присваивание результату операции: 
<br>(i+1)=(j=2+y); (float)i=1.012 
<br><br>Элементы массивов адресуются косвенно поэтому допустимы выражения 
<br><br> int area[];
<br>area[i]=log2(i);
<br>area[i]++;
<br>area[i]*=125;
<br><br>Особенность языка С: любые операции допускаются только со скалярными объектами, причем небольшого размера порядка размера регистров процессора. Это объясняется ориентацией языка на задачи системного программирования. Любые действия с громоздкими объектами - массивами, строками (частный случай массива), структурами реализуются посредством операции вызова функций. Например, рассмотрим сложные объекты
<br><br>int x[100], y[100];
<br>char c[80];
<br>struct {
<br>int code;
<br>float data[1000];
<br>} s1, s2;
<br><br>Примеры правильной реализации операций присваивания для таких объектов: 
<br>содержимое массива y присвоить содержимому массива x 
<br>memcpy(x,y,sizeof(x)); 
<br>массиву с присвоить значение строки "0123456789" 
<br>strcpy(c,"0123456789"); 
<br>содержимое структуры s2 присвоить содержимому структуры s1 
<br>memcpy(&s1,&s2,sizeof(s1)); 
<br>Операции присваивания в стиле языка PL/1 или dBASE вида 
<br>x=y, c="0123456789", s1=s2 
<br>в языке С интерпретируются как присваивание значений указателей на объекты. Здесь в левой части - константы, поэтому приведенные операции обнаружит как ошибочные компилятор.
</p>
<a name="7_2"></a>
<div class="header">7.2 Арифметические операции </div>

<p>
Перечень арифметических операций в языке С и их обозначений: 
<br>+ - сложение; 
<br>- - вычитание либо изменение знака; 
<br>/ - деление (при целочисленных операндах - с отбрасыванием остатка) ; 
<br>* - умножение; 
<br>% - остаток от деления целочисленных операндов со знаком первого операнда (деление по модулю). 
<br><br>Как и в других языках высокого уровня, допустимым являются унарные операции (+ -). Операндами арифметических операций могут быть любые арифметические выражения. Тип выражений при необходимости приводится к более масштабному для обеспечения правильности результата. <br>Обязательные преобразования даже однотипных операндов перед выполнением арифметических операции: 
<br>float --> double; char, short --> int. 
<br>Необязательные преобразования разнотипных операндов: 
<br>int --> unsigned -->long --> double. 
<br>Единственной исключительной ситуацией при выполнении арифметических операций считается деление на нуль, а другие виды ситуаций (переполнение, исчезновение порядка или потеря значимости) игнорируются. Операции (* / %) обладают приоритетом над операциями (+ -), поэтому при записи сложных выражений можно использовать общепринятые математические правила: 
x+y*z-a/b <===> x+(y*z)-(a/b) 
</p>


<a name="7_3"></a>
<div class="header">7.3 Операции отношений </div>

<p>
<br>Перечень операций отношений между объектами в языке С и их обозначения: 
<br>== - равно или эквивалентно; 
<br>!= - не равно; 
<br>< - меньше; 
<br><= - меньше либо равно; 
<br>> - больше; 
<br>>= - больше либо равно. 
<br><br>Символы пар символов {==,!=,<=,>=} разделять нельзя. 
<br>Общий вид операций отношений 
<br><выражение_1> <знак_операции> <выражение_2> 
<br>Операндами могут быть любые скалярные типы. Значения операндов после вычисления перед сравнением преобразуются к одному типу. Арифметические операнды преобразуются по правилам, аналогичным для арифметических операций. Операнды-указатели преобразуются в целые числа необходимого типа. Результат сравнения указателей будет корректным в арифметическом смысле лишь для объектов одного массива. Результат операции отношения - целое значение 1, если отношение истинно, или 0 в противном случае. Следовательно, операция отношения может использоваться в любых арифметических выражениях. 
<br><br>Примеры использования операций отношений: 
<br>     y>0
<br>     x==y
<br>     x!=2
<br>     y=x*(z>2)+(d==1);
<br><br>Рассмотрим примеры ошибочного использования операций отношений в синтаксически правильных выражениях:
<br><br>Попытка конструирования выражений в математическом стиле записи: 
<br>     0<x<100  <===> (0<x)<100  <===> 1 /* Тавтология */
<br>Правильные варианты выражения: 
<br>      0<x && x<100
<br>     (0<x)&&(x<100)
 <br>    (0<x) * (x<100)  /* Допустимо, но неэффективно */
<br>(символы && обозначают операцию конъюнкции - см. 3.5). 
<br><br>Попытка сравнения сложных объектов в различных областях памяти по их адресам: 
<br>char x[40]; x=="Фамилия" <===> 0 
<br>Отношения между нескалярными объектами приходится проверять посредством последовательного сравнения их элементов. Удобно для этих целей воспользоваться библиотечными функциями. Например, требуемое выше сравнение строк символов можно записать в виде 
<br>strсмр(x,"Фамилия") 
<br>(функция int strcmp(char *x,char *y) выполняет лексикографическое сравнение двух строк: нуль - совпадение строк, положительное число - признак "x>y", отрицательное число - признак "x<y"). 
<br><br>Сложные объекты можно рассматривать как массивы символов типа unsigned char. Сравнение массивов s1 и s2 символов такого типа длиной n байт выполняет функция 
<br>int memcmp(void *s1, void *s2, unsigned n), 
<br>(результат формируется подобно функции strcmp). 
<br><br>Например, рассмотрим сложные объекты 
<br>     int x[100], y[100];

<br>     struct {
<br>      int code;
<br>      float data[1000];
 <br>    } s1, s2;
<br><br>Примеры правильной реализации операций сравнения для таких объектов: 
<br>memcmp(x,y,sizeof(x)) - сравнение массивов x и y; memcmp(&s1,&s2,sizeof(s1)) - сравнение <br>структур s1 и s2. 
<br><br>Упомянутые библиотечные функции могут правильно выявлять эквивалентность содержимого полей памяти. Использование их для установления отношений порядка для арифметических данных (напр., "больше", "меньше") приведет к ошибке, если игнорировать внутреннее представление данных. Например, рассмотрим два числа: 0x01020304l и 0x00000005l. Их представление в памяти ППЭВМ на основе микропроцессора 8086/808286 <04030201> и <05000000>. Функция memcmp при упрощенной интерпретации ее результата "установит", что первое число больше второго.
</p>

<a name="7_4"></a>
<div class="header">7.4. Логические операции </div>

<p>
Перечень логических операций в языке С в порядке убывания от носительного приоритета и их обозначения: 
<br>! - отрицание (логическое НЕТ); 
<br>&& - конъюнкция (логическое И); 
<br>|| - дизъюнкция (логическое ИЛИ). 
<br><br>Символы пар символов {||,&&} разделять нельзя. 
<br>Общий вид операции отрицания 
<br>!<выражение> 
<br>Общий вид операций конъюнкции и дизъюнкции 
<br><выражение_1><знак_операции><выражение_2> 
<br>Операндами логической операции могут быть любые скалярные типы. Ненулевое значение операнда трактуется как "истина", а нулевое - "ложь". Результатом операции может быть 1 либо 0 целого типа. 
<br>!0 <===> 1 !5 <===> 0 
<br>int x,y; x=10; !((x=y)>0) <===> 0 
<br><br>Относительный приоритет логических операций позволяет пользоваться общепринятым математическим стилем запмси сложных логических выражений. Например, выражение 
<br>!x && (y>0) || (z==1) && (k>0) 
<br>эквивалентно следующему варианту выражения со скобками 
<br>((!x) && (y>0)) ||((z==1) && (k>0)) 
<br><br>Особенность операций конъюнкции и дизъюнкции - экономное последовательное вычисление выражений-операндов: 
<ul>
	<li>если выражение_1 операции конъюнкции равно нулю, то результат операции - нуль, а выражение_2 не вычисляется; 
	<li>если выражение_1 операции дизъюнкции не равно нулю, то результат операции - единица, а выражение_2 не вычисляется. 
</ul>
Таким образом, появляется возможность записью логического выражения задать условную последовательность вычисления выражений в направлении слева направо: 
<br>scanf("%d",&i)&&test1(i)&&test2(i) - нулевой результат одной из функций приведет к игнорированию вызова остальных; 
<br>search1(x)||search2(x)||search3(x) - только ненулевой результат одной из функций приведет к игнорированию вызова остальных; char *p=NULL; /* ... */ p && p[0]=='*' - проверить первый элемент массива, если указатель на массив не пустой. 
</p>
<a name="8"></a>
<div class="header">8.  Операторы </div>
<p>
<a name="8_1"></a>
<div class="header">8.1.  Условные операторы  </div>

<p>
В языке С имеется две разновидности условных операторов: простой и полный операторы условного выполнения. 
<br>Синтаксис простого оператора условного выполнения: 
<br>if (выражение) оператор 
<br><br>Элемент "оператор" подлежит выполнению, если "выражение" от лично от нуля. 
<br>Примеры записи: 
<pre><div class="code">
if (x>0) x=0;
if (i!=1) j++, l=1; <===> if (i!=1) { j++, l=1; }
if (getch()!=27) {
k=0;
}

if (i) exit(1);  <===>  if (i!=0) exit(1);
if (i>0) if (i<n) k++; <===> if ((i>0)&&(i<n)) k++;
if (1) i=0; <===> i=0;
</div></pre>

Синтаксис полного оператора условного выполнения: 
<br>      if (выражение) оператор_1
<br>      else оператор_2
<br><br>Если "выражение" отлично от нуля, то подлежит выполнению "оператор_1", иначе - "оператор_2". 
<br>Примеры записи:
<pre><div class="code"> 
if (x>0) j=k+1;
else m=i+10;
if (x) {
y=i++;
k=sfn(i);
} else {
printf("\n ???");
exit(0);
}
</div></pre>
Элементы "оператор_1" и(или) "оператор_2" могут быть любым оператором, в том числе и условным оператором. Фраза "else ..." относится к непосредственно предшествующей ей фразе "if ...", поэтому для устранения коллизий условных операторов разных уровней вложенности необходимо заключать их в фигурные скобки:
<pre><div class="code">  
if (!x) if (!y) printf("\n x=YES, y=YES");
else printf("\n x=NO"); /* x=0 <===> (x!=0)&&(y==0) ??? */

if (!x) {
if (!y) printf("\n x=YES, y=YES");
} else printf("\n x=NO");
</div></pre>
</p>
<a name="8_2"></a>
<div class="header">8.2.  Операторы цикла   </div>

<p>
Перечень разновидностей операторов цикла:
<ul> 
	<li>оператор цикла с предусловием; 
	<li>оператор цикла с постусловием; 
	<li>оператор цикла с предусловием и коррекцией. 
</ul>
Синтаксис оператора цикла с предусловием: 
<br>while (выражение) оператор 
<br><br>(элемент "оператор" может быть пустым оператором, оператором-выражением или операторным блоком). Смысл оператора: на каждой итерации цикла предварительно проверяется условие продолжения цикла - ненулевое значение "выражения", затем выполняется "оператор". Элемент "оператор" может включать любое количество управляющих операторов, связанных с конструкцией while: 
<br>continue - переход к следующей итерации цикла; 
<br>break - выход из цикла. 
<br><br>Примеры записи:
</p> 
<pre><div class="code">
while (i>0) i<<=1, j++;
     while (printf("\n n-?"), scahf(" %d",&n));
        ...
     while (1) { /* Организация бесконечного цикла */
      /* ... */
      if (kbhit()&&(getch()==27)) break; /* Выход по ESC */
      /* ... */
     }
     while (!kbhit()); /* Активное ожидание нажатия клавиши */    
</div></pre>
<p>
Синтаксис оператора цикла с постусловием: 
<br>do оператор while (выражение);
<br>(элемент "оператор" может быть пустым оператором, оператором выражением или операторным блоком). Смысл оператора: на каждой итерации цикла предварительно выполняется "оператор", затем проверяется условие продолжения цикла - ненулевое значение "выражения". Назначение используемых в элементе "оператор" управляющих операторов continue и break совпадает с ранее рассмотренным, но оператор continue вызывает переход к этапу оценки "выражения". 
</p>
<pre><div class="code"> 
     do printf("\n ???");
      while (!scanf(" %d",&n));
      ...
      float *x;
      int i=0;
      ...
      m=coreleft()/sizeof(*x);
      do {
       printf("\n n-?");
       if (!scanf(" %d",&n)) {
        sound(300);
        printf(" Вводите цифры !");
        continue;
       }
      if (n>m) continue;
       if (!scanf(" %f",x+i)) break;
      } while (++i<n);
</div></pre>
<p>
Синтаксис оператора цикла с предусловием и коррекцией: 
<br>for (инициализация; условие_выполнения; коррекция) оператор
<br>Здесь "инициализация", "условие_выполнения" и "коррекция" выражения, которые могут отсутствовать (пустые выражения), но символы ';' опускать нельзя. Оператор-выражение "инициализация" выполняется один раз перед началом итераций цикла. Итерации цикла продолжаются, пока истинно "условие_выполнения" - выражение пустое либо непустое выражение отлично от нуля. На каждой итерации последовательно выполняются "оператор" и оператор-выражение "коррекция". Назначение используемых в элементе "оператор" управляющих операторов continue и break совпадает с ранее рассмотренным.
</p>
<pre><div class="code">  
        float  x[10], y;
        int  i,n;
        ...
        for (i=n=sizeof(x)/sizeof(*x); i>0; x[--i]=0);
        ...
        for (i=0; i<n; x[i++]=0);

        for (i=0; i<n; i++) x[i]=0;
        ...
        for (i=0, i=0; i<n; i++)
         if (x[i]<0) y+=x[i];
        ...
</div></pre>
<p>
Различные формы операторов цикла могут выражаться друг через друга, например: 
<br>а) оператор 
<br>     for (инициализация; условие_выполнения; коррекция) оператор
<br>эквивалентен последовательности операторов 
<br>       инициализация;
<br>       while (условие_выполнения) {
<br>        оператор;
<br>        коррекция;
<br>       }
<br><br>(здесь "оператор" не может включать операторы break или continue); 
<br><br>б) оператор 
<br>    for (; условие_выполнения;) оператор
<br>эквивалентен оператору 
<br>     while (условие_выполнения) оператор;
<br><br>в) оператор 
<br>     for (оператор; условие_выполнения;) оператор
<br>эквивалентен оператору 
<br>     do оператор while (условие_выполнения);
<br><br>г) оператор 
<br>     for (;;) оператор
<br>эквивалентен оператору 
<br>     while (1) оператор;
<br><br>(вместо 1 здесь может быть любое число, отличное от нуля). 
<br><br>При использовании вложенных циклов следует учитывать, что управляющие операторы break и continue действуют внутри собственного цикла. Для выхода из вложенного цикла приходится использовать оператор безусловного перехода goto: 
</p>
<pre><div class="code">  
float x[10][20];
int i,j;

  /* Проверка наличия отрицательных значений */

     for (i=0; i<10; i++)
      for (j=0; j<20; j++)
       if (x[i][j]<0) goto next_step;

     next_step: printf("\nЭлемент (%d,%d) отрицателен...");
</div></pre>
<a name="8_3"></a>
<div class="header">8.3.  Оператор выбора альтернатив (переключатель) 
Синтаксис:</div>

<p>
<br>      switch (выражение) { ------------------------------------
<br>
<br>       case константа_1: оператор_1                 Тело
<br>       case константа_2: оператор_2               оператора
<br>                              ...                  switch
<br>      default:  оператор_N
<br>     } ------------------------------------------------------
<br><br>Ключевое слово default и целочисленные значения констант рассматриваются как специальные метки операторов, область действия которых - тело оператора switch. Порядок следования таких меток не регламентирован. Целочисленное выражение сравнивается после вычис ления со значениями констант-меток. При совпадении с одной из них выполняется передача управления соответствующему оператору в теле оператора switch. В случае несовпадения значения выражения с одной из констант - переход на метку default либо, при ее отсутствии, к оператору, следующему за оператором switch. Упомянутые здесь специальные метки в теле оператора switch недолжны повторяться или использоваться для ссылок в операторе goto. Для выхода из тела оператора switch используют управляющий оператор break (дополнительно можно воспользоваться операторами goto или return, а при вложенности в оператор цикла и оператором continue). Рассмотрим пример построения простейшего калькулятора для вычисления значений функций sin(),cos(),log(),sqrt(),tan(). 
</p>

<pre><div class="code">
#include <stdio.h>
#include <math.h>
#include <conio.h<

char f[]="\n %s(%lf)=%lf";

void main() {
 double x;

 while (sound(1000),
        printf("\n x-? "),
        nosound(),
        scanf("%lf",&x)) {
  for (;;) {
   printf("\n x=%lf, Sin, Cos, Log, sQrt, Tan - ? ",x);
   switch(getch()) {
    case 27 : goto cont; /* 27 - код клавиши ESC */
    case 's':
    case 'S': printf(f,"sin",x,sin(x));
              break;
    case 'c':
    case 'C': printf(f,"cos",x,cos(x));
              break;
    case 'l':
    case 'L': printf(f,"log",x,log(x));
              break;
    case 'q':
    case 'Q': printf(f,"sqrt",x,sqrt(x));
              break;
    case 't':
    case 'T': printf(f,"tan",x,tan(x));
              break;
    default:  sound(100);
    printf("\n Select Sin, Cos, Log, sQrt, Tan or ESC");
    nosound();
   }
  }
  cont:;
 }
}
</div></pre>

<p>
Очевидно, что здесь оператор switch можно заменить вложенными условными операторами:
</p>
<pre><div class="code">
     int i;
     ...
     i=getch();
     if ((i=='s')||(i=='S')) printf(f,"sin",x,sin(x));
     else if ((i=='c')||(i=='C')) printf(f,"cos",x,cos(x));
     ...
     else if ((i=='t')||(i=='T')) printf(f,"tan",x,tan(x));
     else {
      sound(100);
      printf ...
      nosound();
     }
</div></pre>
<p>
В последнем варианте используется последовательная проверка условий, его вычислительная сложность 6/2 (половина количества альтернатив). Оператор switch реализуется переходом по адресу, выбираемому из инвертированной таблицы меток по значению выражения, поэтому его вычислительная сложность близка к единице.
</p>
<a name="8_4"></a>
<div class="header">8.4.  Операторы передачи управления </div>
<p>
Формально к операторам передачи управления относятся: 
<br><br>а) оператор безусловного перехода 
<br>         goto метка;
<br><br>б) оператор перехода к следующему шагу (итерации) цикла 
<br>         continue;
<br>(игнорирование оставшихся операторов тела цикла); 
<br><br>в) выход из цикла либо оператора switch 
<br>         break;
<br>(передача управления следующему оператору); 
<br><br>г) оператор возврата их функции 
<br>         return;
<br>         return выражение;
<br>(прекращение выполнения текущей функции и возврат управления вызвавшей программе с передачей, при необходимости, значения выражения). 
<br><br>Операторы вида a...в рассматривались ранее. Оператор return обязательно необходим в функциях, возвращающих значения. В функциях, не возвращающих результат, он неявно присутствует после последнего оператора. Значение "выражения" при необходимости будет преобразовано к типу возвращаемого функцией значения.
</p>

<pre><div class="code">
     void error(void *x, int n) {
      if (!x) printf("\nМассив не создан");
      if (!n) printf("\nМассив пустой");
     }

     float estim(float *x, int n) {
      int i;
      float y;
      if ((!x)||(!n) {
       error(x,n);
       return 0;
      }
      for (y=i=0; i<n; i++)
       y+=x[i];
      return y/n;
     }
</div></pre>

<p>
Строго говоря, в языке C имеются дополнительные возможности передачи управления: 
<ul>
	<li>нелокальный переход, организуемый парой функций longjump и setjump; 
	<li>операторы структурного управления исключениями _try/_except и _try/finally.

</ul>
<p>
<a name="9"></a>
<div class="header">9. Индивидуальные задания</div>

<p>
Находятся в файле <a href="Индивидуальные задания_01.html" target="_blank">« Индивидуальные задания »</a>
</p>
<center>[<a href="#0">Оглавление</a>][<a href="index.html">Содержание</a>][<a href="Лабораторная работа №2.html">Следующая работа</a>]</center>

</body>
</html>