<html>
<head>
<title>ЛАБОРАТОРНАЯ РАБОТА №2</title>
<link href=style.css rel=stylesheet type=text/css>
</head>
<body>
<div class="title"><A name=REF_1_C></A>ЛАБОРАТОРНАЯ РАБОТА №2</div><br>
<div class="title"><A name=REF_1_1_1></A>ФУНКЦИИ В ЯЗЫКЕ С</div>
<p>
<center>[<a href="Лабораторная работа №1.html">Предыдущая работа</a>][<a href="#0">Оглавление</a>][<a href="index.html">Содержание</a>][<a href="Лабораторная работа №3.html">Следующая работа</a>]</center>
		
<br>
<br>
<div class="title">

<a name="0"></a>Оглавление</div>
		
<ol type="1">
			
<li>
<a href="#1">Цель работы</a>			
</li>
			
<li>		
<a href="#2">Функции в языке С и структура программы</a>
</li>
			
<ul>
			
<li>				
<a href="#2_1">Определение функции</a>
</li>
			
<li>
<a href="#2_2">Способ передачи параметров</a>
</li>
			
<li>
<a href="#2_3">Функция main</a>
</li>
			
<li>
<a href="#2_4">Глобальные (внешние) переменные. Инициализация</a>
</li>
			
<li>
<a href="#2_5">Области действия функций. Определения и объявления</a>
</li>
			
<li>
<a href="#2_6">Вызов функции</a>
</li>

</ul>

<li>
<a href="#3">Индивидуальные задания</a>			
</li>
		
</ol>
		
<br>
<br>





<p>
<a name="1"></a>
<div class="header">1. Цель работы</div>
</p>
<div class="header">1.1. Знакомство с правилами организации функций в языке С</div>
<div class="header">1.2. Получение навыков практического программирования с использованием собственных функций</div>
<p>
<a name="2"></a>
<div class="header">2. Функции в языке С и структура программы</div>
<p>
Функция является не только средством написания некоторой части программы, но и служит для оформления логически завершенного действия с собственным набором входных и выходных параметров. Термин «функция», принятый в С, имеет в других языках программирования родственные термины – процедура, модуль. Функция является основной программной единицей уже потому, что вся программа представляет собой множество вызывающих друг друга функций. Часть из них может быть получена «со стороны» – из библиотек или из программ, написанных в другое время, в другом месте, другими людьми и даже на другом языке программирования. То есть на уровне функций осуществляется «сборочный процесс» программы из отдельных составляющих.</p>
<a name="2_1"></a>
<div class="header">2.1. Определение функции</div>
<p>
Функция состоит из двух частей: <i>заголовка</i> создающего «интерфейс» функции к внешнему миру, и <i>тела функции</i> реализующего заложенный и нее алгоритм с использованием внутренних локальных данных. Вместе заголовок и тело составляют <i>определение функции</i>.
<br>Интерфейс функции состоит из <i>имени функции, списка формальных параметров</i> (вход) и <i>типа результата</i> (выход).
Формальные параметры – это собственные переменные функции, которым при ее вызове присваиваются значения фактических параметров.
<br>Список формальных параметров имеет синтаксис определений обычных переменных. Использование их в теле функции не отличается от использования обычных переменных.
<br>Результат функции – это временная переменная, которая возвращается функцией и может быть использована как операнд в контексте (окружении) выражения, где был произведен ее вызов.
<br>Поскольку все переменные в С имеют типы, тип результата также должен быть определен. Это делается в заголовке функции тем же способом, что и для обычных переменных. Используется тот же самый синтаксис, в котором имя функции выступает в роли переменной-результата:
</p>

<pre><div class="code">
int sum(...);   // Результат – целая переменная
char * FF(...); // Результат – указатель на символ
</div></pre>

<p>
Значение переменной-результатa устанавливается в операторе return, который производит это действие наряду с завершением выполнения функции и выходом из нее. Между ключевым словом return и ограничивающим символом «;» может стоять любое выражение, значение которого и становится результатом функции. Если необходимо, производиться преобразование типа, соответствующего выражению, к типу результата функции:
</p>

<pre><div class="code">
double FF() {
  int nn;         // Эквивалент
  return (nn+1);  // FF = (double)(nn + 1)
}
</div></pre>

<p>
Имеется специальный пустой тип результата – void, который обозначает, что функция не возвращает никакого результата и, соответственно, не может быть вызвана внутри выражения. Оператор return в такой функции также не содержит никакого выражения: 
</p>

<pre><div class="code">
void Nothing() {
  ...
  return;
}
</div></pre>

<p>
Вызов функции выглядит как имя функции, за которым в скобках следует список <i>фактических параметров</i>.
<br>Фактические параметры – переменные, константы или выражения, значения которых при вызове присваиваются соответствующим по списку формальным параметрам.
<br>В С формальными параметрами и результатом функции могут быть только переменные, занимающие ограниченный объем памяти: базовые типы данных и указатели. Это сделано, исходя из общего положения о том, что транслятор не должен оказывать сильное влияние на эффективность программы путем включения каких-либо неявных операций копирования. Использование же массивов и структур в этом качестве приведет к появлению таких операций копирования. 
<br>Тело функции представляет собой уже известную нам синтаксическую конструкцию – блок. Это простая последовательность операторов, заключенная в фигурные скобки. После открывающейся скобки в блоке могут стоять определения переменных. Это <i>локальные переменные</i> функции. Они обладают следующими свойствами:
<ul>
	<li>локальные переменные создаются в момент входа в блок (тело функции) и уничтожаются при выходе из него; 
	<li>локальные переменные могут использоваться только в том блоке, в котором они определены. Это значит, что за пределами блока они «не видны»; 
	<li>инициализация локальных переменных заменяется присваиванием им значений во время их создания при входе в блок. Поскольку под инициализацией понимается процесс установки начальных значений переменных в процессе трансляции (которые затем попадают в программный код), то для локальных переменных это сделать принципиально невозможно.
</ul>
<br>Локальные переменные в теле функции обозначаются в С термином <i>автоматические</i>.
</p>
<a name="2_2"></a>
<div class="header">2.2. Способ передачи параметров</div>
<p>
В С принят способ передачи параметров, который называется <i>передачей по значению</i>. Выглядит он так:
<ul>
	<li>формальные параметры являются собственными переменными функции;
	<li>при вызове функции происходит присваивание значений фактических параметров формальным (копирование первых во вторые);
	<li>при изменении формальных параметров значения соответствующих им фактических параметров не меняются.
</ul>
<p>
Единственным исключением из этого правила является передача имени массива в качестве параметра. В этом случае формальный параметр также является собственной переменной, но не массивом, а указателем на него. Поэтому размерность такого массива в функции несущественна и может отсутствовать, а изменение элементов массива – формального параметра приводит к изменению значений массива – фактического параметра функции:
</p>

<pre><div class="code">
int sum(int s[], int n) { // сумма элементов массива
  int z = 0;              // размерность передается
  int i;                  // отдельным параметром
  for (i=0; i < n; i++) z += s[i]; 
  return(z);
}
int c[10] = {1,6,4,7,3,56,43,7,55,33};
void main() {
  int nn;
  nn = sum(c, 10);
}
</div></pre>

<p>
Коль скоро формальные параметры функции являются псевдопеременными, которые при вызове содержат копии фактических параметров, на них распространяются все соглашения о типах данных и переменных. В частности, в заголовке функции используется стандартный контекстный способ определения типа переменной:
</p>

<pre><div class="code">
void f(char **p, int A[], void (*f)())
{...}
</pre></div>

<p>
Исторически сложилось, что первоначальный синтаксис определения функции принципиально исключал возможность контроля транслятора за соответствием количества и типов формальных и фактических параметров. С одной стороны, это позволяло использовать механизм вызова функций и передачи параметров нестандартными способами, а, с другой стороны, являлось причиной многочисленных, трудно обнаруживаемых ошибок.
<br>В связи с этим был введен новый синтаксис определения, а также объявления функции, называемый прототипом. Если вызывается функция, определенная или объявленная по прототипу, то транслятор проверяет соответствие формальных и фактических параметров и, по возможности, выполняет неявные преобразования типов.
</p>
<a name="2_3"></a>
<div class="header">2.3. Функция main</div>
<p>
Функция <b>main</b>, с которой начинается выполнение С-программы, может быть определена с параметрами, которые передаются из внешнего окружения, например, из командной строки. Во внешнем окружении действуют свои правила представления данных, а точнее, все данные представляются в виде строк символов. Для передачи этих строк в функцию <b>main</b> используются два параметра, первый параметр служит для передачи числа передаваемых строк, второй для передачи самих строк. Общепринятые (но не обязательные) имена этих параметров <>bargc и argv</b>. Параметр <b>argc</b> имеет тип <b>int</b>, его значение формируется из анализа командной строки и равно количеству слов в командной строке, включая и имя вызываемой программы (под словом понимается любой текст не содержащий символа пробел). Параметр <b>argv</b> это массив указателей на строки, каждая из которых содержит одно слово из командной строки. Если слово должно содержать символ пробел, то при записи его в командную строку оно должно быть заключено в кавычки.
<br>Функция <b>main</b> может иметь третий параметр, который принято называть <b>argp</b>, и который служит для передачи в функцию <b>main</b> параметров операционной системы (среды) в которой выполняется С-программа.
Заголовок функции main может иметь следующий вид: 
</p>

<pre><div class="code">
int main (int argc, char *argv[], char *argp[]) 
</div></pre>
Если, например, командная строка С-программы имеет вид: 
<pre><div class="code">
A:\>cprog working 'C program' 1 
</pre></div>

<p>то аргументы <b>argc, argv, argp</b> могут представляться в памяти как показано в схеме

<pre><div class="code">
argc = 4
argv [0] = “A:\\cprog.exe\0”
     [1] = “working\0”
     [2] = “C program\0”
     [3] = “1\0”
     [4] = NULL
argp [0] = “path=A:\\;C:\\\0”
     [1] = “lib=D:\\LIB\0”
     [2] = “include=D:\\INCLUDE\0”
     [3] = “conspec=C:\\COMMAND.COM\”
     [4] = NULL
</div></pre>

<p>Операционная система поддерживает передачу значений для параметров <b>argc, argv, argp</b>, а на пользователе лежит ответственность за передачу и использование фактических аргументов функции <b>main</b>.
<br>Следующий пример представляет программу печати фактических аргументов, передаваемых в функцию <b>main</b> из операционной системы и параметров операционной системы.
<br>Пример:

<pre><div class="code">
int main(int argc, char *argv[], char *argp[]) {
  int i = 0;
  printf("\n Имя программы %s", argv[0]);
  for(i = 1; i <= argc; i++)
  printf("\n аргумент %d равен %s", argv[i]);
  printf("\n Параметры операционной системы:");
  while(*argp) {
    printf("\n %s", *argp);
    argp++;
  }
  return 0;
}
</div></pre>

Доступ к параметрам операционной системы можно также получить при помощи библиотечной функции getenv, ее прототип имеет следующий вид:
<pre><div class="code">
char * geteuv(const char *varname); 
</div></pre>
<p>
Аргумент этой функции задает имя параметра среды, указатель на значение которой выдаст функция <b>getenv</b>. Если указанный параметр не определен в среде в данный момент, то возвращаемое значение NULL.
<br>Используя указатель, полученный функцией <b>getenv</b>, можно только прочитать значение параметра операционной системы, но нельзя его изменить. Для изменения значения параметра системы предназначена функция <b>putenv</b>.
</p>
<a name="2_4"></a>
<div class="header">2.4. Глобальные (внешние) переменные. Инициализация</div>
<p>
Программа в целом представляет собой просто набор функций с обязательной функцией <b>main</b>, имеющих каждая собственный набор локальных переменных. Но кроме этого в ее состав включаются еще переменные, доступные сразу нескольким функциям. Такие переменные называются <i>глобальными</i> (в С – <i>внешними</i>). Будучи определенными в любом месте программы вне тела функции, они становятся доступными любой функции, следующей за их объявлением по тексту программы:
</p>

<pre><div class="code">
-int B[10];
¦int sum()
¦{...B[i]... }
¦ -int n;
¦ ¦
¦ ¦void nf()
¦ ¦{...B[i]...n...}
¦ ¦
¦ ¦ -char c[80];
¦ ¦ ¦ void main()
¦ ¦ ¦ {...B[i]...n...c[k]...}
L-+-+---------- Области действия переменных B,n,c
</div></pre>

<p>
Глобальные (внешние) переменные являются наиболее «стабильными» данными в программе. Транслятор переводит их во внутреннее представление, в котором им соответствуют определенные адреса выделенной памяти. Можно сказать, что эти переменные находятся в программе (программном файле) еще до загрузки ее в память. Поэтому их можно инициализировать.
<br><i>Инициализация</i> – присваивание переменным во время трансляции начальных значений, которые сохраняются во внутреннем представлении программы и устанавливаются при загрузке программы в память перед началом ее работы 
<br>Инициализация включается в синтаксис определения переменной:
</p>
<pre><div class="code">
int a = 5, B[10] = {1,5,4,2}, C[] = { 0,1,2,3,4,5 };
</div></pre>
<p>
Инициализатор отделяется от переменной в ее определении знаком «=». Для простой переменной – это обычная константа, для массива – список констант, заключенных в фигурные скобки и разделенных запятыми. Заметим, что размерность массива может отсутствовать, если транслятор в состоянии определить ее из инициализирующего списка.
</p>
<a name="2_5"></a>
<div class="header">2.5. Области действия функций. Определения и объявления</div>
<p>
До сих пор ничего не говорилось ни о взаимном расположении в программе определения функции и ее вызова, ни о соответствии формальных и фактических параметров, ни о контроле такого соответствия. Конечно, нельзя считать, что транслятор «знает» о всех функциях, когда либо написанных, либо находящихся в библиотеках, текстовых файлах и т.д.. Каждая программа должна сама сообщать транслятору необходимую информацию о функциях, которые она собирается вызывать, а именно:
<ul>
	<li>имя функции;
	<li>тип результата;
	<li>список формальных параметров (переменные и типы).
</ul>
<br>При ее наличии транслятор может корректно сформировать вызов функции, даже если ее текст (определение) отсутствует в программе.
<br>Вся перечисленная информация о функции находится в ее заголовке. Таким образом, достаточно этот заголовок привести отдельно, и проблема корректного вызова решается. Такой заголовок называется <i>объявлением функции</i> или в рассматриваемом варианте синтаксиса <i>прототипом</i>.
<br><i>Объявление функции</i> – заголовок функции (без тела функции), необходимый транслятору для формирования корректного вызова функции, если она по каким-либо причинам ему недоступна
<br>Причины такого «незнания» транслятора следующие. Во-первых, трансляторы обычно используют довольно простые алгоритмы просмотра текста программы, «не заглядывая» вперед. Поэтому обычно на данный момент трансляции содержание текста программы за текущим транслируемым оператором ему неизвестно. Во-вторых, функция может быть в библиотеке. В третьих – в другом текстовом файле, содержащем часть С-программы. Во всех этих случаях необходимо использовать объявления. Единственный случай, когда этого делать не надо – когда определение функции присутствует ранее по тексту программы:
</p>

<pre><div class="code">
intB[10];
int sum(int s[],int n); // Объявление функции,
// определенной далее по тексту
// Объявление библиотечной функции
// с переменным числом параметров
extern int printf(char *,...);
// Объявление функции без 
// параметров из другого файла программы
extern int other(void);

void main() {
  sum(B,10);// Вызовы объявленных функций
  printf("%d",B[i]);
  other();
}

int sum(int s[], int n) {
  ...
}
</div></pre>

<p>
Из примера видно, что объявление функции практически дублирует заголовок, отличаясь в некоторых деталях:
<ul>
	<li>объявление заканчивается символом «;»;
	<li>если функция находится вне текущего файла, то объявление предваряется служебным словом <b>extern</b>; 
	<li>имена переменных в списке формальных параметров объявления могут отсутствовать; 
	<li>если функция не имеет формальных параметров, то в объявлении присутствует формальный параметр типа <b>void</b>.
</ul>
<br>Имея предварительно определенную функцию или ее объявление (прототип), транслятор в состоянии проверить соответствие формальных и фактических параметров функции как по их количеству, так и по типам. При этом транслятор может выполнить неявные преобразования типов фактических параметров к типам формальных, если это потребуется:
</p>

<div class="code">
extern double sin(double);
int x;
double y;
y = sin(x); // неявное преобразование (double)x
</div></pre>
<a name="2_6"></a>
<div class="header">2.6. Вызов функции</div>
<p>
Фактические параметры записываются в стек перед вызовом функции, начиная с последнего в списке. Поскольку аппаратный стек расположен «вверх дном» и «растет» от старших адресов к младшим, то этим обеспечивается прямой порядок размещения их в памяти. Формальные параметры представляют собой «ожидаемые» смещения в стеке, по которым должны после вызова находиться соответствующие фактические параметры. Таким образом, сам механизм вызова функции соответствие параметров устанавливает только «по договоренности» между вызывающей и вызываемой функциями, а транслятор при использовании прототипа проверяет эти соглашения.
<p>
<a name="3"></a>
<div class="header">3. Индивидуальные задания</div>

<p>
Находятся в файле <a href="Индивидуальные задания_02.html" target="_blank">« Индивидуальные задания »</a>
</p>
<center>[<a href="Лабораторная работа №1.html">Предыдущая работа</a>][<a href="#0">Оглавление</a>][<a href="index.html">Содержание</a>][<a href="Лабораторная работа №3.html">Следующая работа</a>]</center>

</body>
</p>
</html>