<html>
<head>
<title>ЛАБОРАТОРНАЯ РАБОТА №3</title>
<link href=style.css rel=stylesheet type=text/css>
</head>
<body>
<div class="title"><A name=REF_1_C></A>ЛАБОРАТОРНАЯ РАБОТА №3</div><br>
<div class="title"><A name=REF_1_1_1></A>АДРЕСНАЯ АРИФМЕТИКА И УПРАВЛЕНИЕ ПАМЯТЬЮ</div>
<p>
<center>[<a href="Лабораторная работа №2.html">Предыдущая работа</a>][<a href="#0">Оглавление</a>][<a href="index.html">Содержание</a>][<a href="Лабораторная работа №4.html">Следующая работа</a>]</center>
		
<br>
<br>
<div class="title">

<a name="0"></a>Оглавление</div>
		
<ol type="1">
			
<li>
<a href="#1">Цель работы</a>			
</li>
			
<li>		
<a href="#2">Адресная арифметика, управление памятью</a>
</li>
			
<ul>
			
<li>				
<a href="#2_1">Общие положения</a>
</li>
			
<li>
<a href="#2_2">Присваивание указателей различного типа</a>
</li>
			
<li>
<a href="#2_3">Явное преобразование типа указателя</a>
</li>
			
<li>
<a href="#2_4">Роль операции sizeof в управлении памятью</a>
</li>
			
<li>
<a href="#2_5">Указатель типа void*</a>
</li>
			
<li>
<a href="#2_6">Работа с областью памяти переменного формата</a>
</li>

<li>
<a href="#2_7">Указатели и многомерные массивы</a>
</li>

<li>
<a href="#2_8">Библиотечные функции</a>
</li>

<li>
<a href="#2_9">Динамическое размещение массивов средствами языка С</a>
</li>


</ul>

<li>
<a href="#3">Управление памятью средствами Win32 API</a>			
</li>

<ul>

<li>				
<a href="#3_1">Функции для работы с памятью</a>
</li>


<li>				
<a href="#3_2">Перемещаемая память</a>
</li>


<li>				
<a href="#3_3">Другие функции и флаги</a>
</li>


<li>				
<a href="#3_4">Функции управления виртуальной памятью</a>
</li>

</ul>
<li>
<a href="#4">Индивидуальные задания</a>			
</li>
		
</ol>
		
<br>
<br>



<p>
<a name="1"></a>
<div class="header">1. Цель работы</div>
</p>
<div class="header">1.1. Знакомство с указателями в языке Си.</div>
<div class="header">1.2. Ознакомления с функциями работы с памятью языка Си и Windows API.</div>
<div class="header">1.3. Приобретение практических навыков управления памятью в программах.</div>
<p>
<a name="2"></a>
<div class="header">2. Адресная арифметика, управление памятью</div>
<p>
<a name="2_1"></a>
<div class="header">2.1. Общие положения</div>
</p>
<p>
При работе с памятью редко (может быть, и никогда) придется использовать что-нибудь кроме функций из стандартной библиотеки языка C. Причина, по которой рекомендуется использовать библиотечные функции C (<b>malloc, realloc, calloc, free</b> и т. д.), состоит в том, что они просты и понятны. Но самое главное заключается в том, что не возникнет никаких проблем при использовании этих функций в программах, написанных для Windows. Хотя использовать библиотечные функции языка C удобно, возможно, в принципе, написание программы для Windows вообще без использования этих функций. Каждая библиотечная функция, которая требует обращения к операционной системе (в частности функции управления памятью) имеет соответствующую, и, как правило, более развитую и гибкую функцию операционной системы.
<br>Под управлением памятью имеются в виду возможности программы по размещению и манипулированию данными. Поскольку единственным «представителем» памяти в программе выступают переменные, то управление памятью определяется тем, каким образом работает с ними и с образованными ими структурами данных язык программирования.
<br>Большинство языков программирования однозначно закрепляет за переменными их типы данных и ограничивает работу с памятью только теми областями, в которых эти переменные размещены. Программист не может выйти за пределы самим же определенного шаблона структуры данных. С другой стороны, это позволяет транслятору обнаруживать допущенные ошибки как в процессе трансляции, так и в процессе выполнения программы.
<br>В языке Си ситуация принципиально иная по двум причинам. Во-первых, наличие операции адресной арифметики при работе с указателями позволяет, в принципе, выйти за пределы памяти, выделенной транслятором под переменную и адресовать память как «до» так и «после» нее. Другое дело, что это должно производиться <i>осознанно и корректно</i>. Во-вторых, присваивание и преобразование указателей различных типов, речь о котором пойдет ниже, позволяет рассматривать одну и ту же память «под различным углом зрения» в смысле типов заполняющих ее переменных.
</p>
<a name="2_2"></a>
<div class="header">2.2. Присваивание указателей различного типа</div>
<p>
Операцию присваивания указателей различных типов следует понимать как назначение указателя в левой части на ту же самую область памяти, на которую назначен указатель в правой. Оба указателя после присваивания содержат один и тот же адрес. Но поскольку тип переменных у них может быть разный, то эта область памяти по правилам интерпретации указателя будет рассматриваться как заполненная переменными либо одного, либо другого типа:
</p>

<pre><div class="code">
char *pc, A[20];
int  *pi;
long *pl;
pc = A;	pi = pc; pl = pc;
</div></pre>

<p>
В этом примере <i>pc</i> – указатель на область байтов, <i>pi</i> – на область целых, <i>pl</i> – на область длинных целых. Соответственно операции адресной арифметики <i>*(pc+i), *(pi+i), *(pl+i)</i> адресуют <i>i</i>-ый байт, <i>i</i>-ое целое и <i>i</i>-ое длинное целое от начала области (рис. 2.1):
</p>

<p>
<table border=1 bordercolor="black"cellpadding=5 cellspacing=0>
<font family="verdana" size=12px>
<caption align="bottom">
<font family="verdana" size=2>
<i>(рис. 2.1)</i>
</font>
</caption>
<tr>
 <td colspan=10 align=center valign=center>A</tr>
<tr>
 <td align=center><font family="verdana" size=2>pc-></font></td>
 <td align=center><font family="verdana" size=2>char[0]</font></td>
 <td align=center><font family="verdana" size=2>char[1]</font></td>
 <td align=center><font family="verdana" size=2>char[2]</font></td>
 <td align=center><font family="verdana" size=2>char[3]</font></td>
 <td align=center><font family="verdana" size=2>char[4]</font></td>
 <td align=center><font family="verdana" size=2>char[5]</font></td>
 <td align=center><font family="verdana" size=2>char[6]</font></td>
 <td align=center><font family="verdana" size=2>char[7]</font></td>
 <td valign=center>...</td>
</tr>
<tr>
 <td align=center><font family="verdana" size=2>pi-></font></td>
 <td align=center colspan=2><font family="verdana" size=2>int[0]</font></td>
 <td align=center colspan=2><font family="verdana" size=2>int[1]</font></td>
 <td align=center colspan=2><font family="verdana" size=2>int[2]</font></td>
 <td align=center colspan=2><font family="verdana" size=2>int[3]</font></td>
 <td valign=center>...</td>
</tr>
<tr>
 <td align=center><font family="verdana" size=2>pl-></font></td>
 <td align=center colspan=4><font family="verdana" size=2>long[0]</font></td>
 <td align=center colspan=4><font family="verdana" size=2>long[1]</font></td> 
 <td valign=center>...</td>
</font>
</table>   
</p>

<pre><div class="code">
*(pc + 2) = 5;// записать 5 во 2-й байт области A
*(pi + 1) = 7;// записать 7 в 1-е слово области A
*(pl + 0) = 9;// записать 9 в 0-е двойное слово области A
</pre></div>

<p>
Таким образом, область памяти имеет различную структуру (байты, слова и т.д.) в зависимости от того, через какой указатель к ней обращаться. При этом неважно, что сама область определена как массив типа <b>char</b> – это имеет отношение только к операциям использующим идентификатор массива.
<br>Присваивание значения указателя одного типа указателю другого типа сопровождается действием, которое называется <i>преобразованием типа указателя</i>. На самом деле это действие не приводит к каким-либо преобразованиями данных (команды транслятором не генерируются). Транслятор просто запоминает, что тип переменной изменился и операции адресной арифметики и косвенного обращения нужно выполнять с учетом нового типа указателя. При присваивании происходит автоматическое неявное преобразование типа указателя, которое в транслятор обычно сопровождает соответствующим предупреждением.
<br>Таким образом, операция присваивания указателя включает в себя:
<ul>
	<li>присваивание адреса от правого указателя к левому; 
	<li>неявное преобразование типа указателя от правого к левому.
</ul>
</p>
<a name="2_3"></a>
<div class="header">2.3. Явное преобразование типа указателя</div>
<p>
Рассмотрим три операции присваивания:
</p>

<pre><div class="code">
char *pc, A[20];
int  *pi;
pc = A;
pi = pc;
*(pi + 2) = 5;
*((int*)pc + 2) = 5;
</div></pre>

<p>
Все они дают одинаковый результат – записывают целое 5 во второе слово области памяти, определенной как массив байтов (символов) с именем A. Однако, если в первом случае используется промежуточный указатель типа <b>int*</b>, то в последнем случае такой указатель создается как рабочая переменная, которая получает тип <b>int*</b> и значение переменной pc. Такая операция называется явным преобразованием типа указателя. В скобках указывается абстрактный тип данных – указатель на требуемый тип (например, <b>int*</b>).
</p>
<a name="2_4"></a>
<div class="header">2.4. Роль операции sizeof в управлении памятью</div>
<p>
Операция <b>sizeof</b> вызывает подстановку транслятором соответствующего значения размерности указанного в ней типа данных в байтах. С этой точки зрения она является универсальным измерителем, который должен использоваться для корректного размещения данных различных типов в памяти. Сказанное можно продемонстрировать на простом примере размещения переменных типа <b>double</b> в массиве типа <b>char</b>:
</p>

<pre><div class="code">
#define N 40
double *d;
char   A[N];

for (int i = 0, d = A; i < N / sizeof(double); i++)
       d[i] = (double)i;
</div></pre>

<p>
Следует заметить, что использование операции <b>sizeof</b> позволяет сделать программу переносимой, то есть нечувствительной к разрядности представления данных в различных трансляторах.
</p>
<a name="2_5"></a>
<div class="header">2.5. Указатель типа void*</div>
<p>
Наличие указателя определенного типа предполагает известную организацию памяти, на которую он ссылается. Но в некоторых случаях фрагмент программы «не должен знать» или просто не имеет достаточной информации о структуре данных в этой области. Тогда указатель должен пониматься как адрес памяти как таковой, с неопределенной организацией и неизвестной размерностью указываемых данных. Такой указатель можно присваивать, передавать в качестве параметра и результата функции, но операции косвенного обращения и адресной арифметики с ним недопустимы.
<br>Именно такими свойствами обладает указатель типа <b>void*</b> – указатель на пустой тип <b>void</b> (или другими словами <i>указатель неопределенный тип данных</i>). Наличие его в данном месте программы говорит о том, что она не имеет достаточных оснований для работы с адресуемой областью памяти. Наиболее часто тип <b>void*</b> является формальным параметром или результатом функции. 
<br>Приведем несколько примеров:
</p>

<pre><div class="code">
extern void * malloc(int);
int *p;
p = malloc(sizeof(int)*20);
...
p[i] = i;
</div></pre>

<p>
Функция <b>malloc</b> резервирует память в динамической области памяти и возвращает ее адрес в виде указателя <b>void*</b>. Это означает, что функцией выделяется память как таковая, безотносительно к размещаемым в ней переменным. Вызывающая функция неявно преобразует тип указателя <b>void*</b> в требуемый тип <b>int*</b> для работы с этой областью как с массивом целых переменных.
</p>

<pre><div class="code">
extern int fread(void *, int, int, FILE *);
int A[20];
...	
fread(A, sizeof(int), 20, fd);
</div></pre>

<p>
Функция <b>fread</b> выполняет чтение из двоичного файла <i>n</i> записей длиной по <i>m</i> байтов, при этом структура записи для функции неизвестна. Поэтому начальный адрес области памяти передается формальным параметром типа <b>void*</b>. При подстановке фактического параметра A типа int* производится неявное преобразование его к типу <b>void*</b>.
<br>Как видно из примеров, преобразование типа указателя <b>void*</b> к любому другому типу указателя соответствует «смене точки зрения» программы на адресуемую память от «данных вообще» к «конкретным данным» и наоборот.
</p>
<a name="2_6"></a>
<div class="header">2.6. Работа с областью памяти переменного формата</div>

<p>
Иногда требуется организовать данные в памяти таким образом, что заранее неизвестна точная последовательность переменных различных типов – она определяется некоторым форматом. В этом случае требуется просматривать последовательно область памяти, извлекая из нее переменные разных типов. Такая задача может быть решена с использованием нескольких указателей различного типа, которые сохраняют одинаковое значение (адрес) путем взаимного присваивания. Заметим, что операция <i>*p++</i> применительно к любому указателю интерпретируется как «взять переменную, на которую указывает <i>p</i>, и перейти к следующей», следовательно, значением указателя после выполнения операции будет адрес переменной, следующей за выбранной:
</p>

<pre><div class="code">
char *pc, A[100], c;
int  *pi, i;
long *pl  l;
pl = pi = pc = A;	// назначить все указатели на
				// общий начальный адрес A
i = *pi++;		// взять целое по указателю
pc = pl = pi;		// выровнять значения всех указателей
l = *pl++;		// взять длинное целое по указателю
pc = pi = pl;		// выровнять значения всех указателей
c = *pc++;		// взять байт (символ) по указателю
pi = pl = pc;		// выровнять значения всех указателей
</div></pre>

<p>
Более простой вариант заключается в использовании объединения (<b>union</b>), которое позволяет использовать общую память для размещения своих элементов. Если элементами <b>union</b> являются указатели, то операции присваивания можно исключить (более подробно объединения рассматриваются в следующих работах):
</p>

<pre><div class="code">
union PTR
{
	char *pc;
	int  *pi;
	long *pl;
} ptr;

i = *(ptr.pi)++; l = *(ptr.pl)++; c = *(ptr.pc)++;
</div></pre>
<a name="2_7"></a>
<div class="header">2.7. Указатели и многомерные массивы</div>
<p>
Для двумерных и многомерных массивов в С существуют особенные взаимоотношения с указателями. Для их понимания необходимо напомнить те соглашения, которые заложены в языке для многомерных массивов:
<ul>
	<li>двумерный массив всегда реализован как одномерный массив с количеством элементов, соответствующих первому индексу, причем каждый элемент представляет собой массив элементов базового типа с количеством, соответствующим второму индексу.
<br>Например
</p>

<pre><div class="code">
char A[20][80];
</div></pre>

<p>
определяет массив из 20 массивов по 80 символов в каждом и никак иначе. Массив, таким образом, располагается в памяти по строкам;
	<li>идентификатор массива без скобок интерпретируется как адрес нулевого элемента нулевой строки, или указатель на базовый тип данных. В нашем примере идентификатору A будет соответствовать выражение <i>&A[0][0]</i> с типом <b>char*</b>;
	<li>по аналогии имя двумерного массива с единственным индексом интерпретируется как начальный адрес соответствующего внутреннего одномерного массива. <i>A[i]</i> понимается как <i>&A[i][0]</i>, то есть начальный адрес <i>i</i>-го массива символов.
</ul>
<br>Сказанное справедливо и для N-мерных массивов: многомерный массив представляет собой массив элементов первого индекса, каждый из который представляет собой массив элементов второго индекса и т.д.
</p>

<pre><div class="code">
char A[20][80];
for (int i = 0; i < 20; i++)
{
	//А[i] – указатель на i-ю строку
	//в двумерном массиве символов
	gets(A[i]);	// ввод строки с клавиатуры
}

</div></pre>

<p>
Обычный указатель работает с линейной последовательностью элементов. В этом случае при присваивании начального адреса двумерного массива обычному указателю его двумерная структура «теряется». В следующем примере указатель используется для работы с двумерным массивом с учетом его реального размещения в памяти:
</p>

<pre><div class="code">
char *pc, A[20][80];
pc = A;
//обращение к элементам массива по указателю на базовый тип
... *(pc + i*80 + j) ...	// или
... pc[i*80 + j] ...
</div></pre>

<p>
Для работы с многомерными массивами вводятся особые указатели – указатели на массивы. Они представляют собой обычные указатели, адресуемым элементом которых является не базовый тип, а массив элементов этого типа:
</p>

<pre><div class="code">
char (*p)[][80];
char (*q)[5][80];
</div></pre>

<p>
Круглые скобки имеют здесь принципиальное значение. В контексте определения p является переменной, при косвенном обращении к которой получается двумерный массив символов, то есть p является указателем на двумерный массив. При отсутствии скобок имел бы место двумерный массив указателей на строки. Кроме того, если не используются операции вида «p++» или «p += n», связанные с размерностью указуемого массива, то наличия первого индекса не требуется.
</p>

<pre><div class="code">
p = q = A;	// назначить p и q на двумерный массив
(*p)[i][j]	// j-ый символ в i-ой строке
			// в массиве по указателю p
p += 2;		// переместить p на 2 массива
			// по 5 строк по 80 символов  
</div></pre>
<a name="2_8"></a>
<div class="header">2.8. Библиотечные функции C</div>

<p>
Вы можете определить в программе указатель (например, на массив целых чисел ) следующим образом :
</p>

<pre><div class="code">
int *p; // указатель не инициализирован
</div></pre>

<p>
Можно выделить блок памяти, на который будет указывать p, следующим образом :
</p>

<pre><div class="code">
p = (int *)malloc(1024);
</div></pre>

<p>
При этом выделяется блок памяти размером 1024 байта, который может хранить 512 16-разрядных целых. Указатель, равный <i>NULL</i>, показывает, что выделение памяти не было успешным. Можно также выделить такой блок памяти, используя следующий вызов:
</p>

<pre><div class="code">
p = (int *)calloc(512, sizeof(int));
</div></pre>

<p>
Два параметра функции <b>calloc</b> перемножаются и в результате получается 1024 байта. Кроме того, функция <b>calloc</b> производит заполнение блока памяти нулями.
<br>Если необходимо увеличить размер блока памяти (например, удвоить его), то можно вызвать функцию:
</p>

<pre><div class="code">
p = (int *)realloc(p, 2048);
</div></pre>

<p>
Указатель является параметром функции, и указатель (возможно, отличающийся по значению от первого, особенно, если блок увеличивается) является возвращаемым значением функции.
<br>После того как работа с памятью, выделенной с помощью библиотечных функций, будет завершена ее целесообразно освободить для дальнейшего использования (например другими функциями). Это можно выполнить с помощью функции <b>free</b>, которой необходимо передать адрес освобождаемой памяти. Например:
</p>

<pre><div class="code">
free(p);
</div></pre>
<a name="2_9"></a>
<div class="header">2.9. Динамическое размещение массивов средствами языка С</div>

<p>
При динамическом распределении памяти для массивов следует описать соответствующий указатель и присваивать ему значение при помощи функции <b>calloc</b>. Одномерный массив <i>a[10]</i> из элементов типа <b>float</b> можно создать следующим образом 
</p>

<pre><div class="code">
float * a;
a = (float*)calloc(10, sizeof(float));
</div></pre>

<p>
Для создания двумерного массива вначале нужно распределить память для массива указателей на одномерные массивы, а затем распределять память для одномерных массивов. Пусть, например, требуется создать массив <i>a[n][m]</i>, это можно сделать при помощи следующего фрагмента программы:
</p>

<pre><div class="code">
void main()
{
	double **a;
	int n, m, i;
	scanf("%d %d", &n, &m);
	a = (double **)calloc(m, sizeof(double *));
	for (i = 0; i <= m; i++)
		a[i] = (double *)calloc(n, sizeof(double));
}
</div></pre>

<p>
Аналогичным образом можно распределить память и для трехмерного массива размером NxMxL. Следует только помнить, что ненужную для дальнейшего выполнения программы память следует освобождать при помощи функции <b>free</b>.
</p>

<pre><div class="code">
void main ()
{
	long ***a;
	int n, m, l, i, j;
	scanf("%d %d %d", &n, &m, &l);
/* --------  распределение памяти -------- */
	a = (long ***)calloc(m, sizeof(long **));
	for (i = 0; i <= m; i++)
	{
		a[i] = (long **)calloc(n, sizeof(long *));
		for (j = 0; j <= l; j++)
			a[i][j] = (long *)calloc(l, sizeof(long));
	}
	...
/* --------- освобождение памяти ----------*/
	for (i = 0; i <= m; i++)
	{
		for (j = 0; j <= l; j++) free(a[i][j]);
		free(a[i]);
	}
	free(a);
}
</div></pre>

<p>
Следующий пример интересен тем, что память для массивов распределяется в вызываемой функции, а используется в вызывающей. В таком случае в вызываемую функцию требуется передавать указатели, которым будут присвоены адреса выделяемой для массивов памяти.
<br>Пример:
</p>

<pre><div class="code">
int vvod(double ***, long **);
void main()
{
	double **a;	/*  указатель для массива  a[n][m] */
	long *b;		/*  указатель для массива  b[n]   */
	vvod(&a, &b);
	/* в функцию vvod передаются адреса */
	/* указателей, а не их значения */
	...
}
int vvod(double ***a, long **b)
{
	int n, m, i, j;
	scanf("%d %d", &n, &m);
	*a = (double **)calloc(n, sizeof(double *));
	*b = (long *)calloc(n, sizeof(long));
	for (i = 0; i <= n; i++)
		*a[i] = (double *)calloc(m, sizeof(double));
	...
}
</div></pre>

<p>
Указатель на массив не обязательно должен показывать на начальный элемент некоторого массива. Он может быть сдвинут так, что начальный элемент будет иметь индекс отличный от нуля, причем он может быть как положительным так и отрицательным. 
<br>Пример:
</p>

<pre><div class="code">
void main()
{
	float *q, **b;
	int i, j, k, n, m;
	scanf("%d %d", &n, &m);
	q = (float *)calloc(m, sizeof(float));
/* сейчас указатель q показывает */
/* на начало массива */
	q[0] = 22.3;
	q -= 5;
/* теперь начальный элемент массива имеет */
/* индекс 5,а конечный элемент индекс n-5 */
	q[5] = 1.5;
/* сдвиг индекса не приводит к перераспределению */
/* массива в памяти и изменится начальный элемент*/
	q[6] = 2.5;	/*  –  это второй элемент     */
	q[7] = 3.5;	/*  –  это третий элемент     */
	q+=5;
/* теперь начальный элемент вновь имеет индекс 0,*/
/* а значения элементов q[0], q[1], q[2] равны   */
/* соответственно 1.5, 2.5, 3.5              */
	q+=2;
/* теперь начальный элемент имеет индекс -2,*/
/* следующий -1, затем 0 и т.д. по порядку*/
	q[-2]=8.2;
	q[-1]=4.5;
	q-=2;
/* возвращаем начальную индексацию, три первых*/
/* элемента массива q[0], q[1], q[2], имеют*/
/* значения 8.2, 4.5, 3.5                 */
	q--;
/* вновь изменим индексацию.             */
/* Для освобождения области памяти в которой */
/* размещен  массив q используется функция    */
/* free(q), но поскольку значение указателя  */
/*  *q смещено, то выполнение функции* free(q)*/
/*  приведет к непредсказуемым последствиям. */
/* Для правильного выполнения этой функции    */
/* указатель q должен быть возвращен          */
/* в первоначальное положение                 */
	free(++q);
/* Рассмотрим возможность изменения индексации и*/
/* освобождения памяти для двумерного массива*/
	b=(float **)calloc(m,sizeof(float *));
	for (i=0; i < m; i++)
	b[i]=(float *)calloc(n,sizeof(float));
/* После распределения памяти начальным  */
/* элементом массива будет элемент b[0][0]  */
/* Выполним сдвиг индексов так, чтобы начальным */
/* элементом стал элемент b[1][1]          */
	for (i=0; i < m ; i++) --b[i];
	b--;
/* Теперь присвоим каждому элементу массива */
/* сумму его индексов                */
	for (i=1; i<=m; i++)
		for (j=1; j<=n; j++)
			b[i][j]=(float)(i+j);
/* Обратите внимание на начальные значения */
/* счетчиков циклов i и j, он начинаются с 1 */
/* а не с 0 возвратимся к прежней индексации */
	for (i=1; i<=m; i++) ++b[i];
	b++;
/* Выполним освобождение памяти          */
	for (i=0; i < m; i++) free(b[i]);
	free(b);
	...
}
</div></pre>
<a name="3"></a>
<div class="header">3. Управление памятью средствами Win32 API</div>
<p>
<a name="3_1"></a>
<div class="header">3.1. Функции для работы с памятью</div>
</p>

<p>
Как уже говорилось ранее, все, что можно делать с помощью библиотечных функций C, можно делать самостоятельно, или используя вызовы функций ядра Windows. Ниже приведен пример вызова функции Windows для выделения блока памяти для указателя на целые:
</p>

<pre><div class="code">
DWORD dwSize = 1024;
UINT uiFlags = 0;
p = (int *)GlobalAlloc(uiFlags, dwSize);
</div></pre>

<p>
За исключением одной, для каждой функции, начинающейся со слова <b>Global</b>, существует другая, начинающаяся со слова <b>Local</b>. Эти два набора функций в Windows идентичны. Два различных слова сохранены для совместимости с предыдущими версиями Windows, где функции Global возвращали дальние указатели, а функции <b>Local</b> – ближние.. Если первый параметр задать нулевым, то это эквивалентно использованию флага <b>GMEM_FIXED</b>. Такой вызов функции <b>GlobalAlloc</b> эквивалентен вызову функции <b>malloc</b>.
<br>Следующий пример демонстрирует использование функции изменения размера блока памяти:
</p>

<pre><div class="code">
p = (int *)GlobalReAlloc(p, dwSize, uiFlags);
</div></pre>

<p>
Для определения размера выделенного блока памяти используется функция <b>GlobalSize</b>:
</p>

<pre><div class="code">
dwSize = GlobalSize(p);
</div></pre>

<p>
Функция освобождения памяти:
</p>

<pre><div class="code">
GlobalFree(p);
</div></pre>
<a name="3_2"></a>
<div class="header">3.2. Перемещаемая память</div>

<p>
Функция <b>GlobalAlloc</b> поддерживает флаг <b>GMEM_MOVEABLE</b> и комбинированный флаг для дополнительного обнуления блока памяти (описано в заголовочных файлах Windows):
</p>

<pre><div class="code">
#define GHND (GMEM_MOVEABLE | GMEM_ZEROINIT)
</div></pre>

<p>
Флаг <b>GMEM_MOVEABLE</b> позволяет перемещать блок памяти в виртуальной памяти, при этом функция возвращает не адрес выделенного блока, а 32-разрядный описатель (дескриптор) блока памяти. Это необязательно означает, что блок памяти будет перемещен в физической памяти, но адрес, которым пользуется программа для чтения и записи, может измениться. Для фиксации блока используется вызов :
</p>

<pre><div class="code">
p =(int *)GlobalLock(hGlobal);
</div></pre>

<p>
Эта функция преобразует описатель памяти в указатель. Пока блок зафиксирован, Windows не изменяет его виртуальный адрес. Когда работа с блоком заканчивается, для снятия фиксации вызывается функция:
</p>

<pre><div class="code">
GlobalUnlock(hGlobal);
</div></pre>

<p>
Этот вызов дает Windows свободу перемещать блок в виртуальной памяти. Для того чтобы правильно осуществлять этот процесс следует фиксировать и снимать фиксацию блока памяти в ходе обработки одного сообщения. Когда нужно освободить перемещаемую память, надо вызывать функцию <b>GlobalFree</b> с описателем, но не с указателем на блок памяти.
<br>Если в данный момент нет доступа к описателю, то необходимо использовать функцию :
</p>

<pre><div class="code">
hGlobal = GlobalHandle(p);
</div></pre>

<p>
Для преднамеренного удаления блока памяти можно использовать следующий вызов:
</p>

<pre><div class="code">
GlobalDiscard(hGlobal);
</div></pre>

<a name="3_3"></a>
<div class="header">3.3. Другие функции и флаги</div>

<p>
Другим доступным для использования в функции <b>GlobalAlloc</b> является флаг <b>GMEM_SHARE</b> или <b>GMEM_DDESHARE</b> (идентичны ). Как следует из его имени, этот флаг предназначен для динамического обмена данными. Функции <b>GlobalAlloc</b> и <b>GlobalReAlloc</b> могут также включать флаги <b>GMEM_NODISCARD</b> и <b>GMEM_NOCOMPACT</b>. Эти флаги дают указание Windows не удалять и не перемещать блоки памяти для удовлетворения запросов памяти.
<br><br>Функция <b>GlobalFlags</b> возвращает комбинацию флагов <b>GMEM_DISCARDABLE, GMEM_DISCARDED</b> и <b>GMEM_SHARE</b>. Наконец, вы можете вызвать функцию <b>GlobalMemoryStatus</b> (для этой функции нет функции – двойника со словом <b>Local</b>) с указателем на структуру типа <b>MEMORYSTATUS</b> для определения количества физической и виртуальной памяти, доступной приложению.
<br><br>Windows также поддерживает некоторые функции, реализованные программистом или дублирующие библиотечные функции C. Это функции <b>FreeMemory</b> (заполнение конкретным байтом), <b>ZeroMemory</b> (обнуление памяти), <b>CopyMemory</b> и <b>MoveMemory</b> – обе копируют данные из одной области памяти в другую. Если эти области перекрываются, то функция <b>CopyMemory</b> может работать некорректно. Вместо нее используйте функцию <b>MoveMemory</b>.
</p>
<a name="3_4"></a>
<div class="header">3.4. Функции управления виртуальной памятью</div>

<p>
Windows поддерживает ряд функций, начинающихся со слова <b>Virtual</b>. Эти функции предоставляют значительно больше возможностей управления памятью. Однако, только очень необычные приложения требуют использования этих функций.
<br><br>Последняя группа функций работы с памятью – это функции, имена которых начинаются со слова <b>Heap</b>. Эти функции создают и поддерживают непрерывный блок виртуальной памяти, из которого можно выделять память более мелкими блоками. Следует начинать с вызова функции <b>HeapCreate</b>. Затем, использовать функции <b>HeapAllocate, HeapReAllocate</b> и <b>HeapFree</b> для выделения и освобождения блоков памяти в рамках «кучи».
</p>

<a name="4"></a>
<div class="header">4. Индивидуальные задания</div>

<p>
Находятся в файле <a href="Индивидуальные задания_03.html" target="_blank">« Индивидуальные задания »</a>
</p>
<center>[<a href="Лабораторная работа №2.html">Предыдущая работа</a>][<a href="#0">Оглавление</a>][<a href="index.html">Содержание</a>][<a href="Лабораторная работа №4.html">Следующая работа</a>]</center>



</a>
</p>
</body>
</html>