<html>
<head>
<title>ЛАБОРАТОРНАЯ РАБОТА №4</title>
<link href=style.css rel=stylesheet type=text/css>
</head>
<body>
<div class="title"><A name=REF_1_C></A>ЛАБОРАТОРНАЯ РАБОТА №4</div><br>
<div class="title"><A name=REF_1_1_1></A>ОБРАБОТКА СТРУКТУРИРОВАННЫХ ДАННЫХ</div>

<p>
<center>[<a href="Лабораторная работа №3.html">Предыдущая работа</a>][<a href="#0">Оглавление</a>][<a href="index.html">Содержание</a>][<a href="Лабораторная работа №5.html">Следующая работа</a>]</center>
		
<br>
<br>
<div class="title">

<a name="0"></a>Оглавление</div>
		
<ol type="1">
			
<li>
<a href="#1">Цель работы</a>			
</li>
			
<li>		
<a href="#2">Обработка встроенных структурированных типов данных</a>
</li>
			
<ul>
			
<li>				
<a href="#2_1">Массивы</a>
</li>
			
<li>
<a href="#2_2">Строки символов</a>
</li>
			
<li>
<a href="#2_3">Структуры</a>
</li>
			
</ul>

<li>
<a href="#3">Индивидуальные задания</a>			
</li>
		
</ol>
		
<br>
<br>




<p>
<a name="1"></a>
<div class="header">1. Цель работы</div>
</p>
<div class="header">1.1. Ознакомление со стандартными структурированными типами данных языка С</div>
<div class="header">1.2. Приобретение практических навыков организации и работы с нестандартными типами данных</div>
<p>
<a name="2"></a>
<div class="header">2. Обработка встроенных структурированных типов данных</div>
<a name="2_1"></a>
<div class="header">2.1. Массивы</div>
<p>
В программе на языке Си можно использовать структурированные типы данных. К ним будем относить массивы, структуры и объединения. Массив состоит из многих элементов одного и того же типа. Ко всему массиву целиком можно обращаться по имени. Кроме того, можно выбирать любой элемент массива. Для этого необходимо задать индекс, который указывает его относительную позицию. Число элементов массива назначается при его определении и в дальнейшем не меняется. Если массив объявлен, то к любому его элементу можно обратиться следующим образом: указать имя массива и индекс элемента в квадратных скобках (индексация всегда начинается с нуля). Массивы определяются так же, как и переменные:
</p>

<pre><div class="code">
int a[100];
char b[20];
float d[50];
</div></pre>

<p>
В первой строке объявлен массив <i>а</i> из 100 элементов целого типа. Во второй строке элементы массива <i>b</i> имеют тип <b>char</b>, а в третьей – <b>float</b>. Двумерный массив представляется как одномерный, элементы которого тоже массивы. Например, определение
</p>

<pre><div class="code">
char а[10][20];
</div></pre>

<p>
задает такой массив. По аналогии можно установить и большее число измерений. Элементы двумерного массива хранятся по строкам, т.е. если проходить по ним в порядке их расположения в памяти, то быстрее всего изменяется самый правый индекс. Например, обращение к девятому элементу пятой строки запишется так: <i>а[5][9]</i>.
<br>Пусть задан массив: 
</p>

<pre><div class="code">
int a[2][3]; 
</div></pre>

<p>
Тогда элементы массива а будут размещаться в памяти следующим образом:
</p>

<pre><div class="code">
a[0][0], a[0][1], a[0][2], a[1][0], a[1][1], a[1][2] 
</div></pre>

<p>
Имя массива – это константа, которая содержит адрес его первого элемента (в данном примере а содержит адрес <i>а[0][0]</i>). Предположим, что <i>a</i> = 1000. Тогда адрес элемента <i>а[0][1]</i> будет равен 1002 (элемент типа <b>int</b> занимает в памяти 2 байта), адрес следующего элемента <i>а[0][2]</i> – 1004 и т.д. Если выбрать элемент, для которого не выделена память, может возникнуть ошибка времени выполнения. Т.к компилятор не следит за этим, программа будет откомпилирована, но работать будет неверно.
<br>В языке С существует сильная взаимосвязь между указателями и массивами. Любое действие, которое достигается индексированием массива, можно выполнить и с помощью указателей, причем последний вариант будет быстрее.
<br>Определение int <i>a[5]</i>; задает массив из пяти элементов а[0], a[1], a[2], a[3], a[4]. Если объект <i>у</i> определен как
</p>

<pre><div class="code">
int *у;
</div></pre>

<p>
то оператор <i>у = &a[0]</i>; присваивает переменной <i>у</i> адрес элемента <i>а[0]</i>. Если переменная у указывает на очередной элемент массива а, то <i>y+1</i> указывает на следующий элемент, причем здесь выполняется соответствующее масштабирование для приращения адреса с учетом длины объекта (для типа <b>int</b> – байт, <b>long</b> – 4 байта, (<b>double</b> – 8 байт и т.д.).
<br>Так как само имя массива есть адрес его нулевого элемента, то оператор <i>у = &a[0]</i>; можно записать и в другом виде: <i>у = а</i>. Тогда элемент <i>а[1]</i> можно представить как <i>*(а+1)</i>. С другой стороны, если <i>у</i> – указатель на массив <i>a</i>, то следующие две записи: <i>a[i]</i> и <i>*(у+i)</i> эквивалентны.
<br>Между именем массива и соответствующим указателем есть одно важное различие. Указатель – это переменная и <i>у = а</i>; или <i>y++</i>; – допустимые операции. Имя же массива – константа, поэтому конструкции вида <i>a = y; a++</i>; использовать нельзя, так как значение константы постоянно и не может быть изменено.
<br>Переменные с адресами могут образовывать некоторую иерархическую структуру (могут быть многоуровневыми) типа указатель на указатель (т.е. он содержит адрес другого указателя), указатель на указатель на указатель и т.д. Если указатели адресуют элементы одного массива, то их можно сравнивать (отношения вида, «==», «!=» и другие работают правильно). В то же время нельзя сравнивать ли6о использовать в арифметических операциях указатели на разные массивы (соответствующие выражения не приводят к ошибкам при компиляции, но в большинстве случаев не имеют смысла). Любой адрес можно проверить на равенство или неравенство со значением NULL. Указатели на элементы одного массива можно также вычитать. Тогда результатом будет число элементов массива, расположенных между уменьшаемым и вычитаемым объектами.
<br>Язык Си позволяет инициализировать массив при его определении. Для этого используется следующая форма:
</p>

<pre><div class="code">
тип имя_массива[...] = {список значений};
</div></pre>

<p>
Примеры:
</p>


<pre><div class="code">
int a[5] = {0, 1, 2, 3, 4};
char ch[3] = {'d', 'e', '9'};
int b[2][3] = {{1, 2, 3}, {4, 5, 6}};
</div></pre>

<p>
В языке допускаются массивы указателей, которые определяются, например, следующим образом:
</p>

<pre><div class="code">
char *m[5];
</div></pre>

<p>
Здесь <i>m[5]</i> – массив, содержащий адреса элементов типа <b>char</b>.
</p>
<a name="2_2"></a>
<div class="header">2.2. Строки символов</div>
<p>
Язык С не поддерживает отдельный строковый тип данных, но он позволяет определить строки двумя различными способами. В первом используется массив символов, а во втором – указатель на первый символ массива.
<br>Определение <i>char а[10]</i>; указывает компилятору на необходимость резервирования места для максимум 10 символов. Константа <i>а</i> содержит адрес ячейки памяти, в которой помещено значение первого из десяти объектов типа <b>char</b>. Процедуры, связанные с занесением конкретной строки в массив <i>а</i>, копируют ее по одному символу в область памяти, на которую указывает константа <i>а</i>, до тех пор, пока не будет скопирован нулевой символ, оканчивающий строку. Когда выполняется функция типа <i>printf("%s", а)</i> ей передается значение <i>а</i>, т.е. адрес первого символа, на который указывает <i>а</i>. Если первый символ нулевой, то работа функции <i>printf()</i> заканчивается, а если нет, то она выводит его на экран, прибавляет к адресу единицу и снова начинает проверку на нулевой символ. Такая обработка позволяет снять ограничения на длину строки (конечно, в пределах объявленной размерности): строка может быть любой длины, до тех пор, пока есть место в памяти, куда ее можно поместить.
<br>Инициализировать строку при таком способе определения можно следующим образом:
</p>

<pre><div class="code">
char array[7] = "Строка";
char s[] = {'С', 'т', 'р', 'о', 'к', 'а', '\0'};
</div></pre>

<p>
(при определении массива с одновременной инициализацией пределы изменения индекса можно не указывать).
<br>Второй способ определения строки – это использование указателя на символ. Определение
</p>

<pre><div class="code">
char * b; 
</pre></div>

<p>
задает переменную <i>b</i>, которая может содержать адрес некоторого объекта. Однако в данном случае компилятор не резервирует место для хранения символов и не инициализирует переменную <i>b</i> конкретным значением. Когда компилятор встречает оператор вида
</p>

<pre><div class="code">
b = «IBM PC»;
</pre></div>

<p>
он производит следующие действия. Во-первых, как и в предыдущем случае, он создает в каком-либо месте объектного модуля строку «IBM PC», за которой следует нулевой символ ('\0'). Во-вторых, он присваивает значение начального адреса этой строки (адрес символа 'I') переменной <i>b</i>. Функция <i>printf("%s", b)</i> работает так же, как и в предыдущем случае, осуществляя вывод символов до тех пор, пока не встретится заключительный нуль.
<br>Массив указателей можно инициализировать, т.е. назначать его элементам конкретные адреса некоторых заданных строк при определении.
<br>Для ввода и вывода строк символов помимо <i>scanf()</i> и <i>printf()</i> могут использоваться функции <i>gets()</i> и <i>puts()</i> (их прототипы находятся в файле <i>stdio.h</i>).
<br>Если <i>string</i> – массив символов, то ввести строку с клавиатуры можно так:
</p>

<pre><div class="code">
gets(string);
</pre></div>
<p>
(ввод оканчивается нажатием клавиши <Enter>). Вывести строку на экран можно следующим образом:
</p>
<pre><div class="code">
puts(string);
</pre></div>

<p>
Для работы со строками существует специальная библиотека функций, прототипы которых находятся в файле <i>string.h</i>.
<br>Наиболее часто используются функции <i>strcpy(), strcat(), strlen()</i> и <i>strcmp()</i>. Если <i>string1</i> и <i>string2</i> – массивы символов, то вызов функции <i>strcpy()</i> имеет вид:
</p>

<pre><div class="code">
strcpy(string1, string2);
</pre></div>


<p>Эта функция служит для копирования содержимого строки <i>string2</i> в строку <i>string1</i>. Массив <i>string1</i> должен быть достаточно большим, чтобы в него поместилась строка <i>string2</i>. Так как компилятор не отслеживает эту ситуацию, то недостаток места приведет к потере данных.
<br>Вызов функции strcat() имеет вид:
</p>
<pre><div class="code">
strcat(string1, string2);
</pre></div>


<p>Эта функция присоединяет строку <i>string2</i> к строке <i>string1</i> и помещает ее в массив, где находилась строка <i>string1</i>, при этом строка <i>string2</i> не изменяется. Нулевой байт, который завершал первую строку, заменяется первым байтом второй строки.
<br>Функция <i>strlen()</i> возвращает длину строки, при этом завершающий нулевой байт не учитывается. Если <i>a</i> – целое, то вызов функции имеет вид: 
</p>

<pre><div class="code">
a = strlen(string);
</pre></div>

<p>
Функция <i>strcmp()</i> сравнивает две строки и возвращает 0, если они равны.
</p>

<a name="2_3"></a>
<div class="header">2.3. Структуры</div>
<p>
Структурированная переменная (или просто структура) играет в языке программирования роль, противоположную массиву. Так, если массив представляет из себя упорядоченное множество переменных одного типа, последовательно размещенных в памяти, то структура -аналогичное множество, состоящее из переменных разных типов. Синтаксис определения структурированных переменных в С имеет следующий вид
</p>

<pre><div class="code">
struct man // имя структуры
{
	char name[10]; // элементы структуры
	int dd, mm, yy;
	char * address;
}
// Определение структурированных переменных
man A, B, X[10];
</div></pre>

<p>
Составляющие структуру переменные имеют различные типы и имена, по которым они идентифицируются в структуре. Их называют <i>элементами структуры</i>, и они имеют синтаксис определения обычных переменных. Использоваться где-либо еще, кроме как в составе структурированной переменной, они не могут. В данном примере структура состоит из массива 10 символов <i>name</i>, целых переменных <i>dd, mm</i> и <i>yy</i> и указателя на строку <i>address</i>. После определения элементов структуры следует список структурированных переменных. Каждая из них имеет внутреннюю организацию описанной структуры, то есть полный набор перечисленных элементов. Имя структурированной переменной идентифицирует всю структуру в целом. В данном случае имеются переменные <i>А, B</i> и массив <i>X</i> из 10 структурированных переменных:
<br>Другое важное свойство структуры это наличие у нее имени. Имя структуры идентифицирует данную последовательность элементов, поэтому в программе в дальнейшем можно определять новые структурированные переменные, не раскрывая содержания уже определенной структуры:
</p>

<pre><div class="code">
man C, D, *p;
</pre></div>

<p>
В этом примере видно, что можно определять как сами структурированные переменные, так и указатели на них. Аналогичным образом формальные параметры функции и ее результат также могут быть указателями на структурированные переменные:
</p>

<pre><div class="code">
man *create() {... }
void f(man *q) {... }
</pre></div>
<p>
После определения структуры ее имя приобретает самостоятельное значение и используется в синтаксисе языка аналогично таким ключевым словам как <b>int, long</b> и т.д. Имя структуры при этом является не базовым типом данных, а производным.
<br>При определении глобальной (внешней) структурированной переменной или массива таких переменных они могут быть инициализированы списками значений элементов, заключенных в фигурные скобки и перечисленных через запятую. Например:
</p>

<pre><div class="code">
man A = {"Петров", 1, 10, 1969, "Морская-12"};
man X[10] = {{"Смирнов", 12, 12, 1977, "Дачная-13"},
             {"Иванов", 21, 03, 1945, "Северная-21"}};
</pre></div>

<p>
Способ работы со структурированной переменной вытекает из ее аналогии с массивом. Точно так же, как нельзя выполнить операцию над всем массивом, но можно над отдельным его элементом, структуру можно обрабатывать, выделяя отдельные ее элементы. Для этой цели существует операция «.» (точка), аналогичная операции «[]» в массиве. В структурированной переменной она выделяет элемент с заданным именем:
</p>

<pre><div class="code">
A.name... // элемент name структурированной переменной A
B.dd... // элемент dd структурированной переменной B
</pre></div>

<p>
Если элемент структуры является не простой переменной, а массивом или указателем, то для него применимы соответствующие ему операции ([], * и адресная арифметика):
</p>

<pre><div class="code">
A.name[i]...  // i-й элемент массива name, который является
              // эл-том структурированной переменной A
*B.address... // косвенное обращение по указателю address,
              // который является элементом структурированной
              // переменной B
</pre></div>

<p>
Структура играет особую роль среди всех других способов представления данных. Элементы структуры связаны между собой не только физически (общая память), но и логически, поскольку обычно представляют собой характеристики и свойства одной сущности или предмета, состояние которого отображается в программе. Иначе говоря, структурированная переменная соответствует в программе понятию <i>объекта</i>.
<br>То, что указатели на структурированные переменные имеют широкое распространение, подтверждается наличием в С специальной операции «->» (стрелка, минус-больше), которая понимается как выделение элемента в структурированной переменной, адресуемой указателем. То есть операндами здесь являются указатель на структуру и элемент структуры. Операция имеет полный аналог в виде сочетания операций «*» и «.»:
</p>

<pre><div class="code">
struct man *p,A;
p = &A;
p->mm // эквивалентно (*p).mm
2.4 Объединения
</pre></div>

<p>
Объединение представляет собой структурированную переменную с несколько иным способом размещения элементов в памяти. Если в структуре (как и в массиве) элементы расположены последовательно друг за другом, то в объединении «параллельно». То есть для их размещения выделяется одна общая память, в которой они перекрывают друг друга и имеют в ней общий адрес. Размерность ее определяется максимальной размерностью элемента объединения. Синтаксис объединения полностью совпадает с синтаксисом структуры, только ключевое слово <b>struct</b> заменяется на <b>union</b>:
</p>

<pre><div class="code">
union Dword
{
	long ll;
	int ii[2];
	char cc[4];
	int xx;
} DW;
</pre></div>

<p>
Назначение объединения заключается не в экономии памяти, как может показаться на первый взгляд. На самом деле оно является одним из инструментов управления памятью на принципах, принятых в С. У объединений есть одно важное свойство: если записать в один элемент объединения некоторое значение, то через другой элемент это же значение можно прочитать уже в другой форме представления (как переменную другого типа). То есть форму представления данных в памяти можно менять совершенно свободно:
</p>

<pre><div class="code">
char z;
DW.ll = 0x12345678;
z = DW.cc[2]; // Второй байт в массиве байтов cc в DW имеет
              // значение 0x34. Результат: z получает
              // значение второго байта длинного целого
</pre></div>

<p>
Естественно, что при таком манипулировании внутренним представлением данных, необходимо знать их форматы и размерность.
</p>



<a name="3"></a>
<div class="header">3. Индивидуальные задания</div>

<p>
Находятся в файле <a href="Индивидуальные задания_04.html" target="_blank">« Индивидуальные задания »</a>

<p>
<center>[<a href="Лабораторная работа №3.html">Предыдущая работа</a>][<a href="#0">Оглавление</a>][<a href="index.html">Содержание</a>][<a href="Лабораторная работа №5.html">Следующая работа</a>]</center>


</p>
</body>
</p>
</html>