<html>
<head>
<title>ЛАБОРАТОРНАЯ РАБОТА №5</title>
<link href=style.css rel=stylesheet type=text/css>
</head>
<body>
<div class="title"><A name=REF_1_C></A>ЛАБОРАТОРНАЯ РАБОТА №5</div><br>
<div class="title"><A name=REF_1_1_1></A>РАБОТА С ФАЙЛАМИ</div>

<p>
<center>[<a href="Лабораторная работа №4.html">Предыдущая работа</a>][<a href="#0">Оглавление</a>][<a href="index.html">Содержание</a>][<a href="Лабораторная работа №6.html">Следующая работа</a>]</center>
		
<br>
<br>
<div class="title">
<a name="0"></a>Оглавление</div>
		
<ol type="1">
			
<li>
<a href="#1">Цель работы</a>			
</li>
			
<li>		
<a href="#2">Работа с файлами, синхронный ввод/вывод</a>
</li>
			
<ul>
			
<li>				
<a href="#2_1">Общие понятия, определение файла</a>
</li>
			
<li>
<a href="#2_2">Функции работы с файлами библиотек языка Си</a>
</li>
			
<li>
<a href="#2_3">Функции Windows для работы с файлами</a>
</li>

<ul>
<li>
<a href="#2_3_1">Обзор файлового ввода/вывода</a>
</li>
	
<li>
<a href="#2_3_2">Функции открытия/закрытия файлов</a>
</li>
<ul>
<li>
<a href="#2_3_2_1">Функция создания файла (CreateFile)</a>
</li>

<li>
<a href="#2_3_2_2">Функция CloseHandle</a>
</li>



<li>
<a href="#2_3_2_3">Роль операции sizeof в управлении памятью</a>
</li>


</ul>
<li>
<a href="#2_3_3">Функции работы с файлами</a>
</li>
<ul>
<li>
<a href="#2_3_3_1">Функции чтения/записи файлов (ReadFile и WriteFile)</a>
</li>

<li>
<a href="#2_3_3_2">Функция FlushFileBuffers</a>
</li>

<li>
<a href="#2_3_3_3">Функция SetFilePointer</a>
</li>

<li>
<a href="#2_3_3_4">Функция SetEndOfFile</a>
</li>
</ul>			
<li>
<a href="#2_3_4">Функции блокирования работы с файлами (LockFile и UnlockFile)</a>
</li>
</ul>
</ul>

<li>
<a href="#3">Индивидуальные задания</a>			
</li>
		
</ol>
		

<p>
<a name="1"></a>
<div class="header">1. Цель работы</div>
</p>
<div class="header">1.1. Ознакомление со стандартными функциями работы с файлами языка Си.</div>
<div class="header">1.2. Приобретение практических навыков работы с файлами в ОС Windows</div>

<p>
<a name="2"></a>
<div class="header">2. Работа с файлами, синхронный ввод/вывод</div>
<p>
<a name="2_1"></a>
<div class="header">2.1. Общие понятия, определение файла</div>
</p>
<p>
Файлом называют способ хранения информации на физическом устройстве. Файл – это понятие, которое применимо ко всему – от файла на диске до терминала.
<br>В языке Си отсутствуют операторы для работы с файлами. Все необходимые действия выполняются с помощью функций, включенных в стандартную библиотеку. Они позволяют работать с различными устройствами, такими, как диски, принтер, коммуникационные каналы и т.д. Эти устройства сильно отличаются друг от друга. Однако файловая система преобразует их в единое абстрактное логическое устройство, называемое потоком.
<br>В Си существует два типа потоков: текстовые (text) и двоичные (binary).
<br>Текстовый поток – это последовательность символов. При передаче символов из потока на экран, часть из них не выводится (например, символ возврата каретки, перевода строки).
<br>Двоичный поток – это последовательность байтов, которые однозначно соответствуют тому, что находится на внешнем устройстве.
<br>Прежде чем читать или записывать информацию в файл, он должен быть открыт и тем самым связан с потоком. Это можно сделать с помощью библиотечной функции <b>fopen</b>. Она берет внешнее представление файла (например, «c:\my_prog.txt») и связывает его с внутренним логическим именем, которое используется далее в программе.
<br>Логическое имя – это указатель на требуемый файл. Его необходимо определить; делается это, например, так:
</p>

<pre><div class="code">
FILE * fp;	
</div></pre>

<p>
Здесь <i>FILE</i> – имя типа, описанное в стандартном заголовочном файле <i><stdio.h></i>, <i>fp</i> – указатель на файл. Обращение к функции <i>fopen()</i> в программе осуществляется выражением:
</p>

<pre><div class="code">
fp = fopen(спецификация_файла, "способ_использования_файла")
</div></pre>

<p>
Спецификация файла (т.е. имя файла и путь к нему) может, например, иметь вид: <i>“C:\\my_prog.txt”</i> – для файла <i>my_prog.txt</i> на диске С:.
<br>Способ использования файла задается специальными символами (или их комбинацией) ‘r’, ‘w’, ‘a’ и т.д. Если в результате обращения к функции <i>fopen()</i> возникает ошибка, то она возвращает указатель на константу <i>NULL</i>.
<br>Рекомендуется использовать следующий способ открытия файла:
</p>

<pre><div class="code">
if ((fp = fopen("c:\\my_prog.txt", "rt")) == NULL)
{
	puts("Открыть файл не удалось\n");
	exit(1);
}
</div></pre>

<p>
После окончания работы с файлом он должен быть закрыт. Это делается с помощью библиотечной функции <i>fclose()</i>. Она имеет следующий прототип:
</p>

<pre><div class="code">
int fclose(FILE *fp);
</div></pre>

<p>
При успешном завершении операции функция <i>fclose()</i> возвращает значение нуль. Любое другое значение говорит об ошибке.
</p>
<a name="2_2"></a>
<div class="header">2.2. Функции работы с файлами библиотек языка Си</div>
<p>
Функция <i>putc()</i> записывает символ в файл и имеет следующий прототип:
</p>

<pre><div class="code">
int putc(int с, FILE *fp);
</div></pre>

<p>
Здесь <i>fp</i> – указатель на файл, возвращенный функцией <i>fopen()</i>, с – символ для записи (переменная с имеет тип <b>int</b>, но используется только младший байт). При успешном завершении <i>putc()</i> возвращает записанный символ, в противном случае возвращается константа <i>EOF</i>. Она определена в файле <i><stdio.h></i> и имеет значение -1.
<br>Функция <i>getc()</i> читает символ из файла и имеет следующий прототип:
</p>

<pre><div class="code">
int getc(FILE *fp);
</div></pre>

<p>
Здесь <i>fp</i> – указатель на файл, возвращенный функцией <i>fopen()</i>. Эта функция возвращает прочитанный символ. Соответствующее значение имеет <b>int</b>, но старший байт равен нулю. Если достигнут конец файла, то getc() возвращает значение <i>ЕОF</i>.
<br>Функция <i>feof()</i> определяет конец файла при чтении двоичных данных и имеет следующий прототип:
</p>

<pre><div class="code">
int feof(FILE *fp);
</div></pre>

<p>
Здесь <i>fp</i> – указатель на файл, возвращенный функцией <i>fopen()</i>. При достижении конца файла возвращается ненулевое значение, в противном случае возвращается 0.
<br>Функция <i>fputs()</i> записывает строку символов в файл. Она отличается от функции <i>puts()</i> только тем, что в качестве второго параметра должен быть записан указатель на переменную файлового типа.
<br>Например:
</p>

<pre><div class="code">
fputs("Ехаmple", fp);
</div></pre>

<p>
При возникновении ошибки возвращается значение <i>EOF</i>.
<br>Функция <i>fgets()</i> читает строку символов из файла. Она отличается от функции <i>gets()</i> тем, что в качестве второго параметра должно быть записано максимальное число вводимых символов плюс единица, а в качестве третьего – указатель на переменную файлового типа. Строка считывается целиком, если ее длина не превышает указанного числа символов, в противном случае функция возвращает только заданное число символов. 
<br>Рассмотрим пример:
</p>

<pre><div class="code">
fgets(string, n, fp);
</div></pre>

<p>
Функция возвращает указатель на строку <i>string</i> при успешном завершении и константу <i>NULL</i> в случае ошибки либо достижения конца файла.
<br>Функция <i>fprintf()</i> выполняет те же действия, что и функция <i>printf()</i>, но работает с файлом. Ее отличием является то, что в качестве первого параметра задается указатель на переменную файлового типа. 
<br>Например:
</p>

<pre><div class="code">
fprintf(fp, "%х", а);
</div></pre>

<p>
Функция <i>fscanf()</i> выполняет те же действия, что и функция <i>scanf()</i>, но работает с файлом. Ее отличием является то, что в качестве первого параметра задается указатель на переменную файлового типа. 
<br>Например:
</p>

<pre><div class="code">
fscanf(fp, "%х", &a);
</div></pre>

<p>
При достижении конца файла возвращается значение <i>EOF</i>.
<br>Функция <i>fseek()</i> позволяет выполнять чтение и запись с произвольным доступом и имеет следующий прототип: 
</p>

<pre><div class="code">
int fseek(FILE *fp, long count, int access);
</div></pre>

<p>
Здесь <i>fp</i> – указатель на файл, возвращенный функцией <i>fopen(), count</i> – номер байта относительно заданной начальной позиции, начиная с которого будет выполняться операция, <i>access</i> – способ задания начальной позиции.
Переменная <i>access</i> может принимать следующие значения:
<ul>
	0 – начальная позиция задана в начале файла; 
	<br>1 – начальная позиция считается текущей; 
	<br>2 – начальная позиция задана в конце файла.
</ul>
При успешном завершении возвращается нуль, при ошибке – ненулевое значение.
<br>Функция <i>ferror()</i> позволяет проверить правильность выполнения последней операции при работе с файлами. Имеет следующий прототип:
</p>

<pre><div class="code">
int ferror(FILE *fp);
</div></pre>

<p>
В случае ошибки возвращается ненулевое значение, в противном случае возвращается нуль.
<br>Функция <i>remove()</i> удаляет файл и имеет следующий прототип:
</p>

<pre><div class="code">
int remove(char *file_name);
</div></pre>

<p>
Здесь <i>file_name</i> – указатель на строку со спецификацией файла. При успешном завершении возвращается нуль, в противном случае возвращается ненулевое значение.
<br>Функция <i>rewind()</i> устанавливает указатель текущей позиции в начало файла и имеет следующий прототип:
</p>

<pre><div class="code">
void rewind(FILE *fp);
</div></pre>

<p>
Функция <i>fread()</i> предназначена для чтения блоков данных из потока. Имеет прототип: 
</p>

<pre><div class="code">
unsigned fread(void *ptr,unsigned size,unsigned n,FILE *fp);
</div></pre>

<p>
Она читает <i>n</i> элементов данных, длиной <i>size</i> байт каждый, из заданного входного потока <i>fp</i> в блок, на который указывает указатель <i>ptr</i>. Общее число прочитанных байтов равно произведению n*size. При успешном завершении функция <i>fread()</i> возвращает число прочитанных элементов данных, при ошибке – 0.
<br>Функция <i>fwrite()</i> предназначена для записи в файл блоков данных. Имеет прототип:
</p>

<pre><div class="code">
unsigned fwrite(void *ptr,unsigned size,unsigned n,FILE *fp);
</div></pre>

<p>
Она добавляет <i>n</i> элементов данных, длиной <i>size</i> байт каждый, в заданный выходной файл <i>fp</i>. Данные записываются с позиции, на которую указывает указатель <i>ptr</i>. При успешном завершении операции функция <i>fwrite()</i> возвращает число записанных элементов данных, при ошибке – неверное число элементов данных.
<br>В языке С открываются пять стандартных файлов со следующими логическими именами:
<ul>
	<i>stdin</i> – для ввода данных из стандартного входного потока (по умолчанию c клавиатуры); 
	<br><i>stdout</i> – для вывода данных в стандартный выходной поток (по умолчанию на экран дисплея); 
	<br><i>stderr</i> – файл для вывода сообщений об ошибках (всегда связан с экраном дисплея); 
	<br><i>stdprn</i> – для вывода данных на принтер; 
	<br><i>stdaux</i> – для ввода и вывода данных в коммуникационный канал.
</ul>
В языке С имеется также система низкоуровневого ввода/вывода (без буферизации и форматирования данных), соответствующая стандарту системы UNIX. Прототипы составляющих ее функций находятся в файле <i><io.h></i>.
</p>
<a name="2_3"></a>
<div class="header">2.3. Функции Windows для работы с файлами</div>
<p>
<a name="2_3_1"></a>
<div class="header">2.3.1. Обзор файлового ввода/вывода</div>
</p>
<p>
Обычно, если необходимо открыть файл, используется один из стандартных вызовов библиотеки C (такой как, например, <i>fopen()</i>). В большинстве языков программирования предусмотрены достаточно удобные высокоуровневые средства работы с файлами. Однако в некоторых ситуациях требуется открыть файл и работать с ним на уровне операционной системы, не используя высокоуровневые функции. Например, прямое обращение к операционной системе может потребоваться в случае, если не намерены использовать асинхронный ввод/вывод. Системный вызов, с помощью которого осуществляется открытие файла, называется <i>CreateFile()</i>. На самом деле название этого вызова (в переводе на русский <i>CreateFile</i> – «создать файл») плохо отражает функции, которые он выполняет. В зависимости от флагов, которые передаются этому вызову, он может либо действительно создать новый файл, либо открыть уже существующий. Если файл с указанным именем уже существует на жестком диске, вызов <i>CreateFile()</i> может либо открыть его, либо уничтожить его и создать новый файл с таким же именем. Если файла с указанным именем на жестком диске еще нет, вызов <i>CreateFile()</i> создает такой файл. В любом случае вызов <i>CreateFile()</i> создает дескриптор файла и возвращает его вызвавшей программе, которая может использовать этот дескриптор для дальнейшей работы с файлом.
</p>
<a name="2_3_2"></a>
<div class="header">2.3.2. Функции открытия/закрытия файлов</div>
<p>
<a name="2_3_2_1"></a>
<div class="header"><i>2.3.2.1 Функция создания файла (CreateFile)</i></div>
</p>

<p>
Функция <i>CreateFile()</i> предназначена не только для создания нового файла, но и открытия существующего файла или каталога, а также изменения длины существующего файла. Кроме этого эта функция может выполнять операции над каналами передачи данных (<i>pipe</i>), дисковыми устройствами и консолями.
<br>Прототип функции <i>CreateFile()</i> следующий:
</p>

<pre><div class="code">
HANDLE CreateFile (
  LPCTSTR lpFileName,		// адрес строки имени файла 
  DWORD dwDesiredAccess,	// режим доступа 
  DWORD dwShareMode,		// режим совместного использования
						// файла
  LPSECURITY_ATTRIBUTES
  lpSecurityAttributes,		// дескриптор защиты 
  DWORD dwCreationDistribution,	// параметры создания 
  DWORD  dwFlagsAndAttributes,	// атрибуты файла 
  HANDLE hTemplateFile
);
</div></pre>

<p>
Через параметр <i>lpFileName</i> передается адрес строки, содержащей имя файла, который необходимо создать или открыть. Строка должна быть заканчиваться нулем. Параметр <i>dwDesiredAccess</i> определяет тип доступа, который должен быть предоставлен к открываемому файлу. Здесь можно использовать логическую комбинацию следующих констант:
<ul>
	0 – доступ запрещен, однако приложение может определять атрибуты файла или устройства, открываемого при помощи функции <i>CreateFile()</i>;
	<br><i>GENERIC_READ</i> – разрешен доступ на чтение;
	<br><i>GENERIC_WRITE</i> – разрешен доступ на запись.
</ul>
С помощью параметра <i>dwShareMode</i> задаются режимы совместного использования открываемого или создаваемого файла. Для этого параметра может быть использована комбинация следующих констант:
<ul>
	0 – совместное использование файла запрещено;
	<br><i>FILE_SHARE_READ</i> – другие приложения могут открывать файл с помощью функции <i>CreateFile()</i> для чтения;
	<br><i>FILE_SHARE_WRITE</i> – аналогично предыдущему, но на запись.
</ul>
Через параметр <i>lpSecurityAttributes</i> необходимо передать указатель на дескриптор защиты или значение <i>NULL</i>, если этот дескриптор не используется. В данных примерах не используется дескриптор защиты. Параметр <i>dwCreationDistribution</i> определяет действия, выполняемые функцией <i>CreateFile()</i>, если приложение пытается создать файл, который уже существует.
<br>Параметр <i>dwFlagsAndAttributes</i> задает атрибуты и флаги для файла.
<br>В дополнение к перечисленным выше атрибутам, через параметр <i>dwFlagsAndAttributes</i> вы можете передать любую логическую комбинацию флагов.
<br>И, наконец, последний параметр <i>hTemplateFile</i> предназначен для доступа к файлу шаблона с расширенными атрибутами для создаваемого файла. Этот параметр здесь не рассматривается.
<br><br>В случае успешного завершения функция <i>CreateFile()</i> возвращает идентификатор созданного или открытого файла (или каталога). При ошибке возвращается значение <i>INVALID_HANDLE_VALUE</i> (а не <i>NULL</i>, как можно было бы предположить). Код ошибки можно определить при помощи функции <i>GetLastError()</i>.
<br>В том случае, если файл уже существует и были указаны константы <i>CREATE_ALWAYS</i> или <i>OPEN_ALWAYS</i>, функция <i>CreateFile()</i> не возвращает код ошибки. В то же время в этой ситуации функция <i>GetLastError()</i> возвращает значение <i>ERROR_ALREADY_EXISTS</i>.
</p>
<a name="2_3_2_2"></a>
<div class="header"><i>2.3.2.2 Функция CloseHandle</i></div>

<p>
Функция <i>CloseHandle()</i> позволяет закрыть файл. Она имеет единственный параметр – идентификатор закрываемого файла. Заметим, что если указать функции <i>CreateFile()</i> флаг <i>FILE_FLAG_DELETE_ON_CLOSE</i>, то сразу после закрытия файл будет удален. Как ранее говорилось, такая методика очень удобна при работе с временными файлами.
</p>
<a name="2_3_2_3"></a>
<div class="header">2.4. Роль операции sizeof в управлении памятью</div>
<p>
Операция <b>sizeof</b> вызывает подстановку транслятором соответствующего значения размерности указанного в ней типа данных в байтах. С этой точки зрения она является универсальным измерителем, который должен использоваться для корректного размещения данных различных типов в памяти. Сказанное можно продемонстрировать на простом примере размещения переменных типа <b>double</b> в массиве типа <b>char</b>:
</p>
<a name="2_3_3"></a>
<div class="header">2.3.3. Функции работы с файлами</div>
<p>
<a name="2_3_3_1"></a>
<div class="header"><i>2.3.3.1 Функции чтения/записи файлов (ReadFile и WriteFile)</i></div>
</p>
<p>
С помощью функций <i>ReadFile()</i> и <i>WriteFile()</i> приложение может выполнять, соответственно, чтение из файла и запись в файл. Прототипы функций <i>ReadFile()</i> и <i>WriteFile()</i> следующие:
</p>

<pre><div class="code">
BOOL ReadFile(
  HANDLE  hFile,		// идентификатор файла 
  LPVOID  lpBuffer,		// адрес буфера для данных 
  DWORD nNumberOfBytesToRead,	//количество байт, 
					// которые необходимо прочесть 
					// в буфер 
  LPDWORD lpNumberOfBytesRead,	// адрес слова, 
					// в которое будет записано
					// количество прочитанных байт 
  LPOVERLAPPED lpOverlapped);	// адресс структуры типа OVERLAPPED
							

BOOL WriteFile (
  HANDLE  hFile,		// идентификатор файла
  LPVOID  lpBuffer,		// адрес записываемого блока данных
  DWORD   nNumberOfBytesToWrite,	// количество, байт
						// которые необходимо
						// записать
  LPDWORD lpNumberOfBytesWrite,	// адрес слова, в котором
						// будет сохранено
						// количество записанных байт
  LPOVERLAPPED lpOverlapped);	// адрес структуры OVERLAPPED
</div></pre>

<p>
Через параметр <i>hFile</i> этим функциям необходимо передать идентификатор файла, полученный от функции <i>CreateFile()</i>.
<br>Параметр <i>lpBuffer</i> должен содержать адрес буфера, в котором будут сохранены прочитанные данные (для функции <i>ReadFile()</i>), или из которого будет выполняться запись данных (для функции <i>WriteFile()</i>).
<br>Параметр <i>nNumberOfBytesToRead</i> используется для функции <i>ReadFile()</i> и задает количество байт данных, которые должны быть прочитаны в буфер <i>lpBuffer</i>. Аналогично, параметр <i>nNumberOfBytesToWrite</i> задает функции <i>WriteFile()</i> размер блока данных, имеющего адрес <i>lpBuffer</i>, который должен быть записан в файл.
<br><br>Так как в процессе чтения возможно возникновение ошибки или достижение конца файла, количество прочитанных или записанный байт может отличаться от значений, заданных, соответственно, параметрами <i>nNumberOfBytesToRead</i> и <i>nNumberOfBytesToWrite</i>. Функции <i>ReadFile()</i> и <i>WriteFile()</i> записывают количество действительно прочитанных или записанных байт в двойное слово с адресом, соответственно, <i>lpNumberOfBytesRead</i> и <i>lpNumberOfBytesWrite</i>.
<br>Параметр <i>lpOverlapped</i> используется в функциях <i>ReadFile()</i> и <i>WriteFile()</i> для организации асинхронного режима чтения и записи. Если запись выполняется синхронно, в качестве этого параметра следует указать значение <i>NULL</i>. Способы выполнения асинхронного чтения и записи будут рассмотрены позже. Заметим только, что для использования асинхронного режима файл должен быть открыт функцией <i>CreateFile()</i> с использованием флага <i>FILE_FLAG_OVERLAPPED</i>. Если указан этот флаг, параметр <i>lpOverlapped</i> не может иметь значение NULL. Он обязательно должен содержать адрес подготовленной структуры типа <i>OVERLAPPED</i>.
<br>Если функции <i>ReadFile()</i> и <i>WriteFile()</i> были выполнены успешно, они возвращают значение <i>TRUE</i>. При возникновении ошибки возвращается значение <i>FALSE</i>. В последнем случае вы можете получить код ошибки, вызвав функцию <i>GetLastError()</i>. В процессе чтения может быть достигнут конец файла. При этом количество действительно прочитанных байт (записывается по адресу <i>lpNumberOfBytesRead</i>) будет равно нулю. В случае достижения конца файла при чтении ошибка не возникает, поэтому функция <i>ReadFile()</i> вернет значение <i>TRUE</i>.
</p>
<a name="2_3_3_2"></a>
<div class="header"><i>2.3.3.2 Функция FlushFileBuffers</i></div>

<p>
Так как ввод и вывод данных на диск в операционной системе Windows буферизуется, запись данных на диск может быть отложена до тех пор, пока система не освободится от выполнения текущей работы. С помощью функции <i>FlushFileBuffers()</i> можно принудительно заставить операционную систему записать на диск все изменения для файла, идентификатор которого передается этой функции через единственный параметр:
</p>

<pre><div class="code">
BOOL FlushFileBuffers(HANDLE hFile);
</div></pre>

<p>
В случае успешного завершения функция возвращает значение <i>TRUE</i>, при ошибке – <i>FALSE</i>. Код ошибки вы можете получить при помощи функции <i>GetLastError()</i>.
<br>Заметим, что при закрытии файла функцией <i>CloseHandle()</i> содержимое всех буферов, связанных с этим файлом, записывается на диск автоматически. Поэтому использовать функцию <i>FlushFileBuffers()</i> нужно только в том случае, если запись содержимого буферов нужно выполнить до закрытия файла.
</p>
<a name="2_3_3_3"></a>
<div class="header"><i>2.3.3.3 Функция SetFilePointer</i></div>

<p>
С помощью функции <i>SetFilePointer()</i> приложение может выполнять прямой доступ к файлу, перемещая указатель текущей позиции, связанный с файлом. Сразу после открытия файла этот указатель устанавливается в начало файла. Затем он передвигается функциями <i>ReadFile()</i> и <i>WriteFile()</i> на количество прочитанных или записанных байт, соответственно.
<br>Функция <i>SetFilePointer()</i> позволяет выполнить установку текущей позиции:
</p>

<pre><div class="code">
DWORD SetFilePointer (
  HANDLE hFile,			// идентификатор файла 
  LONG lDistanceToMove,		// количество байт, на которое 
						// будет передвинута текущая 
						// позиция 
  PLONG lpDistanceToMoveHigh,	// адрес старшего слова,
						// содержащего расстояние для 
						// перемещения позиции 
  DWORD  dwMoveMethod		// способ перемещения позиции
);
</div></pre>

<p>
Через параметр <i>hFile</i> передается идентификатор файла, для которого выполняется изменение текущей позиции.
<br>Параметр <i>lDistanceToMove</i>, определяющий дистанцию, на которую будет передвинута текущая позиция, может принимать как положительные, так и отрицательные значения. В первом случае текущая позиция переместится по направлению к концу файла, во втором – к началу файла.
<br>Если планируется работа с файлами, размер которых не превышает 2<sup>32</sup> – 2 байта, для параметра <i>lpDistanceToMoveHigh</i> можно указать значение <i>NULL</i>. В том случае, когда файл очень большой, для указания смещения может потребоваться 64-разрядное значение. Для того чтобы указать очень большое смещение, необходимо записать старшее 32-разрядное слово этого 64-разрядного значения в переменную, и передать функции <i>SetFilePointer()</i> адрес этой переменной через параметр <i>lpDistanceToMoveHigh</i>. Младшее слово смещения следует передавать как и раньше, через параметр <i>lDistanceToMove</i>.
<br>Параметр <i>dwMoveMethod</i> определяет способ изменения текущей позиции.
<br>В случае успешного завершения функция <i>SetFilePointer()</i> возвращает младшее слово новой 64-разрядной позиции в файле. Старшее слово при этом записывается по адресу, заданному параметром <i>lpDistanceToMoveHigh</i>.
<br>При ошибке функция возвращает значение 0xFFFFFFFF. При этом в слово по адресу <i>lpDistanceToMoveHigh</i> записывается значение <i>NULL</i>. Код ошибки можно получить при помощи функции <i>GetLastError()</i>.
</p>
<a name="2_3_3_4"></a>
<div class="header"><i>2.3.3.4 Функция SetEndOfFile</i></div>

<p>
При необходимости изменить длину файла (уменьшить или увеличить), можно воспользоваться функцией <i>SetEndOfFile()</i>. Эта функция устанавливает новую длину файла в соответствии с текущей позицией:
</p>

<pre><div class="code">
BOOL SetEndOfFile(HANDLE hFile);
</div></pre>

<p>
Для изменения длины файла достаточно установить текущую позицию в нужное место с помощью функции <i>SetFilePointer()</i>, а затем вызвать функцию <i>SetEndOfFile()</i>.
</p>
<a name="2_3_4"></a>
<div class="header">2.3.4. Функции блокирования работы с файлами (LockFile и UnlockFile)</div>

<p>
Так как операционная система Windows является мультизадачной и допускает одновременную работу многих процессов, возможно возникновение ситуаций, в которых несколько задач попытаются выполнять запись или чтение для одних и тех же файлов. Например, два процесса могут попытаться изменить одни и те же записи файла базы данных, при этом третий процесс будет в то же самое время выполнять выборку этой записи.
<br><br>Напомним, что если функции <i>CreateFile()</i> указать режимы совместного использования файла <i>FILE_SHARE_READ</i> или <i>FILE_SHARE_WRITE</i>, несколько процессов смогут одновременно открыть файлы и выполнять операции чтения и записи, соответственно. Если же эти режимы не указаны, совместное использование файлов будет невозможно. Первый же процесс, открывший файл, заблокирует возможность работы с этим файлом для других процессов.
<br><br>Очевидно, что в ряде случаев все же необходимо обеспечить возможность одновременной работы нескольких процессов с одним и тем же файлом. В этом случае при необходимости процессы могут блокировать доступ к отдельным фрагментам файлов для других процессов. Например, процесс, изменяющий запись в базе данных, перед выполнением изменения может заблокировать участок файла, содержащий эту запись, и затем после выполнения записи разблокировать его. Другие процессы не смогут выполнить запись или чтение для заблокированных участков файла.
Блокировка участка файла выполняется функцией <i>LockFile()</i>, прототип которой представлен ниже:
</p>

<pre><div class="code">
BOOL LockFile(
  HANDLE hFile,		// идентификатор файла 
  DWORD  dwFileOffsetLow,	// младшее слово смещения области 
  DWORD  dwFileOffsetHigh,	// старшее слово смещения области
  DWORD  nNumberOfBytesToLockLow,	// младшее слово длины 
							// области 
  DWORD  nNumberOfBytesToLockHigh	// старшее слово длины 
							// области
);
</div></pre>

<p>
Параметр <i>hFile</i> задает идентификатор файла, для которого выполняется блокировка области. Смещение блокируемой области (64-разрядное) задается при помощи параметров <i>dwFileOffsetLow</i> (младшее слово) и <i>dwFileOffsetHigh</i> (старшее слово). Размер области в байтах задается параметрами <i>nNumberOfBytesToLockLow</i> (младшее слово) и <i>nNumberOfBytesToLockHigh</i> (старшее слово). Заметим, что если в файле блокируется несколько областей, они не должны перекрывать друг друга.
<br>В случае успешного завершения функция <i>LockFile()</i> возвращает значение <i>TRUE</i>, при ошибке – <i>FALSE</i>. Код ошибки можно получить при помощи функции <i>GetLastError()</i>.
<br>После использования заблокированной области, а также перед завершением своей работы процессы должны разблокировать все заблокированные ранее области, вызвав для этого функцию <i>UnlockFile()</i>:
</p>

<pre><div class="code">
BOOL UnlockFile(
  HANDLE hFile,		// идентификатор файла 
  DWORD  dwFileOffsetLow,	// младшее слово смещения области 
  DWORD  dwFileOffsetHigh,	// старшее слово смещения области
  DWORD  nNumberOfBytesToUnlockLow,	// младшее слово длины 
							// области 
  DWORD  nNumberOfBytesToUnlockHigh	// старшее слово длины 
);							// области
</div></pre>

<p>
Заметим, что в программном интерфейсе операционной системы Windows есть еще две функции, предназначенные для блокирования и разблокирования областей файлов. Эти функции имеют имена, соответственно, <i>LockFileEx()</i> и <i>UnlockFileEx()</i>.
<br>Главное отличие функции <i>LockFileEx()</i> от функции <i>LockFile()</i> заключается в том, что она может выполнять частичную блокировку файла, например, только блокировку от записи. В этом случае другие процессы могут выполнять чтение заблокированной области.
</p>


<p>
<a name="3"></a>
<div class="header">3. Индивидуальные задания</div>

<p>
Находятся в файле <a href="Индивидуальные задания_05.html" target="_blank">« Индивидуальные задания »</a>
</p>
<center>[<a href="Лабораторная работа №4.html">Предыдущая работа</a>][<a href="#0">Оглавление</a>][<a href="index.html">Содержание</a>][<a href="Лабораторная работа №6.html">Следующая работа</a>]</center>

</a>
</p>
</body>
</html>