<html>
<head>
<title>ЛАБОРАТОРНАЯ РАБОТА №6</title>
<link href=style.css rel=stylesheet type=text/css>
</head>
<body>
<div class="title"><A name=REF_1_C></A>ЛАБОРАТОРНАЯ РАБОТА №6</div><br>
<div class="title"><A name=REF_1_1_1></A>ДИНАМИЧЕСКИ ПОДКЛЮЧАЕМЫЕ БИБЛИОТЕКИ</div>
<p>
<center>[<a href="Лабораторная работа №5.html">Предыдущая работа</a>][<a href="#0">Оглавление</a>][<a href="index.html">Содержание</a>][<a href="Лабораторная работа №7.html">Следующая работа</a>]</center>
		
<P>
<div class="title">

<a name="0"></a>Оглавление</div>
		
<ol type="1">
			
<li>
<a href="#1">Цель работы</a>			
</li>
			
<li>		
<a href="#2">Назначение и функции динамически подключаемых библиотек</a>
</li>
			
<ul>
			
<li>				
<a href="#2_1">Основные понятия</a>
</li>
			
<li>
<a href="#2_2">Создание DLL модуля</a>
</li>
			
<li>
<a href="#2_3">Проецирование DLL на адресное пространство процесса</a>
</li>
<ul>			
<li>
<a href="#2_3_1">Неявная компоновка</a>
</li>

<li>
<a href="#2_3_2">Явная компоновка</a>
</li>
			
<li>
<a href="#2_3_3">Функция входа/выхода</a>
</li>
</ul>			
<li>
<a href="#2_4">Использование DLL</a>
</li>
<ul>
<li>
<a href="#2_4_1">Экспорт функций и переменных из DLL</a>
</li>
<li>
<a href="#2_4_2">Импорт функций и переменных из DLL</a>
</li>
<li>
<a href="#2_4_3">Заголовочный файл DLL</a>
</li>
<li>
<a href="#2_4_4">Динамическое связывание без импорта</a>
</li>

</ul>

</ul>

<li>
<a href="#3">Индивидуальные задания</a>			
</li>
		
</ol>
		
<br>
<br>





<p>
<a name="1"></a>

<div class="header">1. Цель работы</div>
</p>
<div class="header">Изучение возможностей применения динамически подключаемых библиотек в ОС Windows, приобретение практических навыков создания и использования DLL.</div>
<p>
<a name="2"></a>
<div class="header">2. Назначение и функции динамически подключаемых библиотек</div>
<p>
<a name="2_1"></a>
<div class="header">2.1. Основные понятия</div>
<p>
Динамически подключаемые библиотеки (DLL, или динамические библиотеки, или библиотеки динамической компоновки, или модули библиотек) являются одним из наиболее важных структурных элементов Windows. Большинство файлов, из которых состоит Windows, представляют из себя либо программные модули, либо модули динамически подключаемых библиотек. Большая часть принципов, относящихся к написанию обычных программ, вполне подходит и для написания этих библиотек, но есть несколько важных отличий.
<br>Как известно, Windows-программа представляет собой исполняемый файл, который обычно создает одно или более окон, а для получения данных от пользователя использует цикл обработки сообщений. Динамически подключаемые библиотеки, как правило, непосредственно не выполняются и обычно не получают сообщений. <b>Они представляют собой отдельные файлы с функциями, которые вызываются программами или другими динамическими библиотеками для выполнения определенных задач. Динамически подключаемая библиотека активизируется только тогда, когда другой модуль вызывает одну из функций, находящихся в библиотеке.</b>
<br>Термин «динамическое связывание» (<i>dinamic linking</i>) относится к процессам, которые Windows использует для того, чтобы связать вызов функции в одном из модулей с реальной функцией из модуля библиотеки. Статическое связывание (<i>static linking</i>) имеет место в процессе создания программы, когда в процессе построения исполняемого (EXE) файла связываются воедино разные объектные (OBJ) модули, файлы библиотек (LIB) и, как правило, скомпилированные файлы описания ресурсов (RES). В отличие от этого динамическое связывание имеет место во время выполнения программы.
<br>Файлы <i>kernel32.dll, user32.dll</i> и <i>gdi32.dll</i>, файлы различных драйверов, например <i>keyboard.drv, system.drv</i> и <i>mouse.drv</i>, драйверы мониторов и принтеров – все это динамически подключаемые библиотеки. Их можно использовать во всех программах Windows. Некоторые динамически подключаемые библиотеки (например, файлы шрифтов) содержат только ресурсы (resource only) и нет текстов программ. Таким образом, одной из целей существования динамически подключаемых библиотек должно быть обеспечение функциями и ресурсами, которые можно использовать во многих, совершенно разных программах.
<br>В традиционной операционной системе содержатся программы, которые для решения каких-то задач могут вызывать другие программы. В Windows принцип вызова одним модулем функций из другого модуля распространен на всю операционную систему. Динамически подключаемые библиотеки (включая те, которые составляют Windows) можно считать дополнением программы.
<br>Хотя модуль динамически подключаемой библиотеки может иметь любое расширение (например, .exe или .fon), <b>стандартным расширением</b>, принятым в Windows, является <b>.dll</b>. Только те динамически подключаемые библиотеки, которые имеют расширение .dll, Windows загрузит автоматически. <b>Если файл имеет другое расширение, то программа должна загрузить модуль библиотеки явно. Для этого используется функция <i>LoadLibrary()</i> или <i>LoadLibraryEx().</i></b>
</p>
<a name="2_2"></a>
<div class="header">2.2. Создание DLL модуля</div>

<p>
Зачастую создать DLL проще, чем написать приложение, потому что она является лишь набором автономных функций, пригодных для использования любой программой, причем в DLL обычно отсутствует код, предназначенный для обработки циклов выборки сообщений или создания окон. Функции DLL пишутся в расчете на то, что их будет вызывать какое-то приложение (ЕХЕ- файл) или другая DLL. Файлы с исходным кодом компилируются и компонуются так же, как и при создании ЕХЕ-файла. Но, создавая DLL, следует указывать компоновщику <b>ключ /DLL</b>, который заставляет компоновщика записывать в конечный файл информацию, по которой загрузчик операционной системы определит, что данный файл – DLL, а не приложение.
<br>Чтобы приложение (или другая DLL) могло вызывать функции из DLL, исполняемый файл <b>нужно сначала спроецировать на адресное пространство вызывающего процесса.</b> Это делается либо неявной компоновкой при загрузке, либо явной – в период выполнения программы.
<br>Как только DLL спроецирована на адресное пространство вызывающего процесса, ее функции доступны всем потокам этого процесса. Фактически библиотеки при этом теряют почти всю индивидуальность: для потоков код и данные DLL – просто дополнительный код и данные, оказавшиеся в адресном пространстве процесса. Когда поток вызывает из DLL какую-то функцию, та считывает свои параметры из стека потока и размещает в этом стеке собственные локальные переменные. Кроме того, любые созданные кодом DLL объекты принадлежат вызывающему потоку или процессу – DLL в Win32 ничем не владеет.
<br>Например, если функция из DLL вызывает <i>VirtualAlloc()</i>, резервируется регион в адресном пространстве того процесса, которому принадлежит поток, обратившийся к функции из DLL. Если DLL будет выгружена из адресного пространства процесса, зарезервированный регион не освободится, так как система не фиксирует того, что регион выделен библиотечной функцией. Считается, что он принадлежит процессу и поэтому освободится, только если поток этого процесса вызовет <i>VirtualFree()</i> или завершится сам процесс.
<br>Когда какой-то процесс проецирует образ DLL файла на свое адресное пространство, система создает также экземпляры глобальных и статических переменных.
<br>Пример использования DLL для разделения данных между двумя приложениями:
<p>
<pre><div class="code">
HGLOBAL g_hData = NULL;
void SetData(LPVOID lpvData, int nSize)
{
	LPVOID lpv;
	g_hData = LocalAlloc(LMEM_MOVEABLE,   nSize);
	lpv = LocalLock(g_hData);
	memcpy(lpv, lpvData, nSize);
	LocalUnlock(g_hData);
}
void GetData(LPVOID lpvData, int nSize)
{
	LPVOID lpv = LocalLock(g_hData);
	memcpy(lpvData, lpv, nSize);
	LocalUnlock(g_hData);
}
</div></pre>

<p>
Вызов <i>SetData()</i> приводит к выделению блока памяти из сегмента данных DLL, копированию в него данных, на которые указывает параметр <i>lpvData</i>, и сохранению описателя блока в глобальной переменной <i>g_hData</i>. Теперь другое приложение может вызвать <i>GetData()</i>. Та, используя глобальную переменную <i>g_hData</i>, блокирует выделенную область локальной памяти, копирует данные из нее в буфер, идентифицируемый параметром <i>lpvData</i>, и возвращает управление.
<br>Вот насколько прост способ разделения данных между двумя процессами в 16-разрядной Windows. В Win32 он не работает: во-первых, у DLL в Win32 нет собственных локальных куч. Во-вторых, глобальные и статические переменные не разделяются между разными проекциями одной DLL; система создает отдельный экземпляр глобальной переменной <i>g_hData</i> для каждого процесса, и значения, хранящиеся в разных экземплярах переменной, не обязательно одинаковы.
</p>
<a name="2_3"></a>
<div class="header">2.3. Проецирование DLL на адресное пространство процесса</div>
<p>
<a name="2_3_1"></a>
<div class="header">2.3.1 Неявная компоновка</div>

<p>
Чтобы поток мог вызвать функцию из DLL-библиотеки, последнюю нужно сначала спроецировать на адресное пространство процесса, которому принадлежит вызывающий поток. Сделать это можно одним из двух способов: неявной компоновкой с функциями DLL и явной загрузкой DLL.
<br>Неявная компоновка (<i>implicit linking</i>) – самый распространенный метод проецирования образа DLL-файла на адресное пространство процесса. При сборке приложения компоновщику нужно указать набор LIB-файлов. Каждый такой файл содержит список функций данной DLL, вызов которых разрешен приложениям (или другой DLL). Обнаружив, что приложение ссылается на функции, упомянутые в LIB-файле для DLL, компоновщик внедряет имя этой DLL в конечный исполняемый файл. При загрузке ЕХЕ-файла система просматривает его образ на предмет определения необходимых ему DLL, после чего пытается спроецировать их на адресное пространство процесса. Поиск DLL осуществляется в: 
<ul>
	<li> каталоге, содержащем ЕХЕ-файл;
	<li> текущем каталоге процесса;
	<li> системном каталоге Windows;
	<li> основном каталоге Windows;
	<li> каталогах, указанных в переменной окружения PATH.
</ul>
<br>Если файл DLL не найден, система отображает окно с соответствующим сообщением и немедленно завершает процесс. Библиотеки, спроецированные на адресное пространство этим методом, не отключаются от него до завершения процесса.
</p>
<p>
<a name="2_3_2"></a>
<div class="header">2.3.2 Явная компоновка </div>
<p>
Образ DLL-файла можно спроецировать на адресное пространство процесса явным образом, для чего один из потоков должен вызвать либо <i>LoadLibrary()</i>, либо <i>LoadLibraryEx()</i>:
</p>
<pre><div class="code">
HINSTANCE LoadLibrary(LPCTSTR IpszLibFile);
HINSTANCE LoadLibraryEx(LPCTSTR  IpszLibFile, 
                        HANDLE hFile, DWORD dwFlags); 
</pre></div>

<p>
Обе функции ищут образ DLL-файла (в каталогах, список которых приведен в предыдущем разделе) и пытаются спроецировать его на адресное пространство вызывающего процесса. Значение типа <i><b>HINSTANCE</i></b>, возвращаемое обеими функциями, <b>сообщает адрес виртуальной памяти, по которому спроецирован образ файла.</b> Если спроецировать DLL на адресное пространство процесса не удалось, функции возвращают NULL.
<br>Следует обратить внимание на 2 дополнительных параметра функции <i>LoаdLibraryEx(): hFile</i> и <i>dwFlags</i>. Первый зарезервирован и должен быть NULL. Во втором можно передать либо 0, либо комбинацию флагов <i>DONT_RESOLVE_DLL_REFERENCES, LOAD_LIВRARY_AS_DATAFILE</i> и <i>LOAD_WITH_ALTERED_SEARCH_PATH.</i>
<br><i>DONT_RESOLVE_DLL_REFERENCES</i> указывает системе спроецировать DLL на адресное пространство вызывающего процесса. Проецируя DLL, система обычно вызывает из нее специальную функцию <i>DllMain()</i> (о ней чуть позже) и с ее помощью инициализирует библиотеку. Данный флаг заставляет систему проецировать DLL, не обращаясь к <i>DllMain()</i>. Кроме того, DLL может импортировать функции из других DLL. При загрузке библиотеки система проверяет, используются ли ею другие DLL; если да, то загружает и их. При установке флага <i>DONT_RESOLVE_DLL_REFERENCES</i> дополнительные DLL автоматически не загружаются.
<br>Флаг <i>LOAD_LIBRARY_AS_DATAFILE</i> очень похож на предыдущий – DLL проецируется на адресное пространство процесса так, будто это файл данных. При этом система не тратит дополнительного времени на подготовку к исполнению какого-либо кода из данного файла.
<br>Данный флаг может понадобиться по нескольким причинам. Во-первых, его стоит указать, если DLL содержит только ресурсы и никаких функций. Тогда DLL проецируется и адресное пространство процесса, после чего при вызове функций, загружающих pecуpcы, можно использовать значение <i>HINSTANCE</i>, возвращенное <i>LoadLibraryEx()</i>. Во-вторых, данный флаг может потребоваться, если нужны ресурсы, содержащиеся в каком-нибудь ЕХЕ-файле. Обычно загрузка такого файла приводит к запуску нового процесса, но этого не произойдет, если его загрузить вызовом <i>LoadLibraryEx()</i> в адресное пространство процесса. Получив значение <i>HINSTANCE</i> для спроецированного ЕХЕ-файла, фактически получают доступ к его ресурсам. Так как в ЕХЕ-файле нет <i>DllMain()</i>, при вызове <i>LoadLibraryEx()</i> для загрузки ЕХЕ-файла нужно указать флаг <i>LOAD_LIBRARY_AS_DATAFILE</i>.
<br>Флаг <i>LOAD_WITH_ALTERED_SEARCH_PATH</i> изменяет алгоритм, используемый <i>LoadLibraryEx()</i> при поиске DLL-файла. Обычно поиск осуществляется так, как было сказано ранее. Однако, если данный флаг установлен, функция ищет файл, просматривая каталоги в таком порядке:
<ul>
	<li> каталог, заданный в параметре <i>lpszLibFile</i>;
	<li> текущий каталог процесса;
	<li> системный каталог Windows;
	<li> основной каталог Windows;
	<li> каталоги, перечисленные в переменной окружения PATH.
</ul>
<br>Существует еще один фактор, который может повлиять на то, где система ищет файлы DLL. В реестре есть раздел:
</p>


<pre><div class="code">
HKLM\SYSTEM\CurrentControlSet\Control\Session Manager\KnownDLLs
</div></pre>


<p>Здесь содержится набор параметров, имена которых совпадают с именами некоторых DLL-файлов. Значения параметров представляют собой строки, идентичные именам параметров.
<br>При вызове <i>LoadLibrary()</i> или <i>LoadLibraryEx()</i>, каждая из них сначала проверяет, указано ли имя DLL вместе с расширением <i>.dll</i>. Если нет, поиск DLL ведется по описанным ранее правилам. Если же расширение <i>.dll</i> указано, функция его отбрасывает и ищет в разделе реестра <i>KnownDLLs</i> параметр с идентичным именем. Если его нет, вновь применяются описанные ранее правила. Если параметр есть – система обращается к значению, связанному с параметром, и пытается загрузить определенную в нем DLL. При этом система ищет DLL в каталоге, на который указывает значение, связанное с параметром реестра <i>DllDirectory</i>. В Windows NT параметру <i>DllDirectory</i> по умолчанию присваивается значение "%SystemRoot%\System32".
<br>Если DLL загружается явно, ее можно отключить от адресного пространства процесса функцией <i>FreeLibrary()</i>.
</p>

<pre><div class="code">
BOOL FreeLibrary(HINSTANCE hinstDll);
</div></pre>

<p>
При вызове <i>FreeLibrary()</i> следует передать значение типа <i>HINSTANCE</i>, которое идентифицирует выгружаемую DLL. Это значение можно получить, предварительно вызвав <i>LoadLibrary()</i> или <i>LoadLibraryEx()</i>.
<br>На самом деле <i>LoadLibrary()</i> и <i>LoadLibraryEx()</i> лишь увеличивают счетчик числа пользователей указанной библиотеки, a <i>FreeLibrary()</i> его уменьшает. Например, при первом вызове <i>LoadLibrary()</i> для загрузки DLL система проецирует образ DLL-файла на адресное пространство вызывающего процесса и присваивает единицу счетчику числа пользователей этой DLL Если поток того же процесса вызывает <i>LoadLibrary()</i> для той же DLL еще раз, DLL больше не проецируется; система просто увеличивает счетчик числа ее пользователей. Чтобы выгрузить DLL из адресного пространства процесса, <i>FreeLibrary()</i> придется теперь вызывать дважды: первый вызов уменьшит счетчик до 1, второй – до 0. Обнаружив, что счетчик числа пользователей DLL обнулен, система отключит ее. После этого попытка вызова какой-либо функции из данной библиотеки приведет к нарушению доступа, так как код по указанному адресу уже не отображается на адресное пространство процесса.
<br>Система поддерживает в каждом процессе свой счетчик DLL, т.е. если поток процесса А вызывает:
</p>

<pre><div class="code">
HINSTANCE hinstDll = LoadLibrary("MyLib.DLL");
</div></pre>



<p>
а затем тот же вызов делает поток в процессе В, то <i>mylib.dll</i> проецируется на адресное пространство обоих процессов, а счетчики числа пользователей DLL в каждом из них приравниваются к 1. Если же поток процесса В вызовет далее
</p>

<pre><div class="code">
FreeLibrary(hinstDll);
</div></pre>

<p>
счетчик числа пользователей DLL в процессе В обнулится, что приведет к отключению DLL от адресного пространства процесса В. Но проекция DLL на адресное пространство процесса А не затрагивается, и счетчик числа пользователей DLL в нем остается прежним.
<br>Чтобы определить, спроецирована ли DLL на адресное пространство процесса, поток может вызвать функцию <i>GetModuleHandle()</i>.
</p>
<pre><div class="code">
HINSTANCE GetModuleHandle(LPCTSTR IpszModuleName);
</div></pre>
<p>
Например, следующий код загружает <i>mylib.dll</i>, только если она еще не спроецирована на адресное пространство процесса:
</p>

<pre><div class="code">
HINSTANCE hinstDll;
hinstDll = GetModuleHandle("MyLib");
if (hinstDll == NULL)
{
	hinstDll = LoadLibrary("MyLib");
}
</div></pre>

<p>
Если имеется значение HINSTANCE для DLL, можно определить и полное имя DLL (или ЕХЕ) с помощью <i>GetModuleFileName()</i>:
</p>
<pre><div class="code">
DWORD GetModuleFileName(HINSTANCE hinstModule,
                        LPTSTR IpszPath, DWORD cchPath);
</div></pre>

<p>
Первый параметр функции – это значение <i>HINSTANCE</i> для ЕХЕ или DLL. Второй задает адрес буфера, в который функция запишет полное имя образа файла. Последний параметр (<i>cchPath</i>) определяет размер буфера в символах.
<br>Уменьшить счетчик числа пользователей DLL можно и с помощью другой Win32-функции:
</p>

<pre><div class="code">
VOID FreeLibraryAndExitThread(HINSTANCE hinstDll,
                              DWORD dwExitCode);
//Она реализована в KERNEL32.DLL так:
VOID FreeLibraryAndExitThread(HINSTANCE hinstDll,
                              DWORD dwExitCode) {
	FreeLibrary(hinstDll);
	ExitThread(dwExitCode);
}
</div></pre>


<p>
Если поток станет сам вызывать <i>FreeLibrary()</i> и <i>ExitThread()</i> по отдельности, возникнет очень серьезная проблема: вызов <i>FreeLibrary()</i> тут же отключит DLL от адресного пространства процесса. После возврата из <i>FreeLibrary()</i> код, содержащий вызов <i>ExitThread()</i>, окажется недоступен, и поток попытается выполнить неопределенный код. Это приведет к нарушению доступа и завершению всего процесса.
<br>Если же поток обратится к <i>FreeLibraryAndExitThread()</i>, она вызовет <i>FreeLibrary()</i> и сразу же отключит DLL. Но следующая исполняемая инструкция находится в <i>kernel32.dll</i>, а не в только что отключенной DLL. Значит, поток сможет продолжить выполнение и вызвать <i>ExitThread()</i>, которая корректно завершит его, не возвращая управления.
</p>
<a name="2_3_3"></a>
<div class="header">2.3.3 Функция входа/выхода</div>
<p>
У DLL может быть одна функция входа/выхода – <i>DllMain()</i>. Система вызывает ее в некоторых ситуациях сугубо в информационных целях, и обычно она используется DLL для инициализации и очистки в конкретных процессах или потоках. Если DLL подобные уведомления не нужны, эту функцию можно не реализовывать. Пример – DLL, содержащая исключительно ресурсы. Но если эта функция в DLL все же есть, она должна выглядеть так:
</p>

<pre><div class="code">
BOOL WINAPI DllMain(HINSTANCE hinstDll, DWORD fdwReason,
                    LPVOID flmpLoad)
{
	switch (fdwReason) {
		case DLL_PROCESS_ATTACH:
			// DLL проецируется на адресное пр-во процесса
			break;
		case DLL_THREAD_ATTACH:
			// создается поток
			break;
		case DLL_THREAD_DETACH:
			// поток завершается корректно
			break;
		case DLL_PROCESS_DETACH:
			// DLL отключается от адресного пр-ва процесса
			break;
	}
	return(TRUE);
}
</div></pre>


<p>
Операционная система вызывает функцию входа/выхода в различных ситуациях, при этом параметр <i>hinstDll</i> содержит описатель экземпляра DLL. Значение этого параметра равно виртуальному адресу, по которому файл DLL проецируется на адресное пространство процесса (как и <i>hinstExe</i> функции <i>WinMain()</i>). Обычно последнее значение сохраняется в глобальной переменной, чтобы его можно было использовать и при вызовах функций, загружающих ресурсы (типа <i>DialogBox()</i> или <i>LoadString()</i>). Если файл DLL загружен неявно, параметр <i>flmpLoad</i> отличен от 0, а если явно – равен 0.
<br>Параметр <i>fdwReason</i> сообщает о причине, по которой система вызвала функцию <i>DllMain()</i>. Он принимает одно из 4 значений:
<ul>
	<li><i>DLL_PROCESS_ATTACH </i>– DLL проецируется на адресное пространство процесса (при первой загрузке);
	<li><i>DLL_PROCESS_DETACH </i>– DLL отключается от адресного пространства процесса; 
	<li><i>DLL_THREAD_ATTACH</i> – в процессе создается новый поток;
	<li><i>DLL_THREAD_DETACH </i>– DLL в процессе уничтожается поток.
</ul>
</p>
<a name="2_4"></a>
<div class="header"> 2.4. Использование DLL</div>
<p>
<a name="2_4_1"></a>
<div class="header"> 2.4.1 Экспорт функций и переменных из DLL</div>

<p>
При создании DLL определяется набор функций доступных для других ЕХЕ- или DLL-модулей. Если DLL-функция доступна для вызова из других программ, то говорят, что это экспортируемая (<i>exported</i>) функция. Кроме функций Win32 позволяет экспортировать и глобальные переменные.
<br>Пример экспорта из DLL функции <i>Add()</i> и глобальной целочисленной переменной <i>g_nUsageCount</i>:
</p>

<pre><div class="code">
__declspec(dllexport) int Add(int nLeft, int nRight)
{
	return(nLeft + nRight);
}
__declspec(dllexport) int g_nUsageCount = 0;
</div></pre>

<p>
Компилятор языка C/C++, компилируя функцию <i>Add()</i> и <i>g_nUsageCount</i>, встраивает в конечный OBJ-файл дополнительную информацию, необходимую для компоновщика при сборке DLL из OBJ-файлов.
<br>Обнаружив такую информацию, компоновщик создает LIB-файл со списком идентификаторов, экспортируемых из DLL. Этот LIB-файл нужен при сборке любого ЕХЕ-модуля, вызывающего функции из данной DLL. Кроме того, компоновщик вставляет в конечный файл DLL и таблицу экспортируемых идентификаторов (<i>exported symbols</i>). Каждый элемент в этой таблице содержит имя экспортируемой функции или переменной, а также адрес этой функции или переменной внутри DLL-файла. Все списки сортируются по алфавиту.
</p>
<a name="2_4_2"></a>
<div class="header">2.4.2 Импорт функций и переменных из DLL</div>
<p>
Чтобы ЕХЕ-модуль мог вызывать функции или получать доступ к переменным из DLL, нужно сообщить компилятору, что они находятся именно в DLL. Следующий фрагмент кода показывает, как импортировать функцию <i>Add()</i> и переменную <i>g_nUsageCount</i>, экспортируемые DLL-модулем:
</p>

<pre><div class="code">
__declspec(dllimport) int Add(int nLeft, int nRight);
__declspec(dllimport) int g_nUsageCount;
</div></pre>

<p>
Конструкция <i>__declspec(dllimport)</i> сообщает компилятору, что функция <i>Add()</i> и переменная <i>g_nUsageCount</i> находятся в DLL, доступ к которой ЕХЕ-модуль должен получить при загрузке. Это заставит компилятор сгенерировать специальный код для импортируемых идентификаторов (<i>imported symbols</i>). Кроме того, компилятор встроит специальную информацию в конечный объектный файл. Она используется при компоновке ЕХЕ-модуля, подсказывая компоновщику, какие функции следует искать в LIB-файлах. Собирая ЕХЕ-файл, компоновщик отыскивает импортируемые функции и переменные. Затем, определив, какой LIB-файл содержит эти идентификаторы, добавляет в таблицу импорта новые элементы. Каждый элемент содержит имя соответствующего DLL-файла, а также имя самого идентификатора. Таблица импорта вносится в конечный ЕХЕ – файл при его записи на жесткий диск.
</p>
<a name="2_4_3"></a>
<div class="header"> 2.4.3 Заголовочный файл DLL</div>
<p>
Обычно при создании DLL создается и ее заголовочный файл, содержащий прототипы всех экспортируемых из DLL функций и переменных. Он понадобится при компиляции ЕХЕ-модулй. Часто его включают и при компиляции исходных файлов самой DLL. Чтобы один и тот же заголовочный файл можно было использовать при компиляции исходных файлов как ЕХЕ-, так и DLL-модулей, он должен выглядеть так:
</p>

<pre><div class="code">
//MYLIBAPI определена в файле реализаций MyLib.с как
//__declspec(dllexport). Поэтому при включении заголовочного
//файла в MyLib.с, функции будут экспортироваться, а не
//импортироваться.

#ifndef	MYLIBAPI
	#define	MYLIBAPI __declspec(dllimport)
#endif

MYLIBAPI int Add(int nLeft,   int riRight);
MYLIBAPI int g_nUsageCount;
</div></pre>

<p>
Этот заголовочный файл надо включать в самое начало исходных файлов DLL следующим образом:
</p>
<pre><div class="code">
//Необходимо определить MYLIBAPI до включения файла MyLib.H.
//Тогда MyLib.H, увидев, что MYLIBAPI уже определена, не
//станет переопределять ее как __declspec(dllimport).

#define	MYLIBAPI	__declspec(dllexport)
#include "MyLib.h"                       
MYLIBAPI int Add(int nLeft, int nRight)
{
	return(nLeft + nRight);
}
MYLIBAPI int g_nUsageCount;
</div></pre>
<p>
Поскольку <i>MYLIBAPI</i> определена как <i>__declspec(dllexport)</i> явно, то при компиляции исходного кода программы компилятор узнает, что функции экспортируются. А это позволяет не повторять <i>__declspec(dllexport)</i> перед каждой процедурой или переменной.
<br>Что касается исходного кода, импортирующего из DLL идентификаторы, то нужно всего лишь включить в него заголовочный файл. Теперь MYLIBAPI будет определена как <i>__declspec(dllimport)</i>, и компилятор «поймет», какие идентификаторы содержатся в DLL. Просмотрев заголовочные файлы Windows, например <i><winuser.h></i>, можно увидеть, что Microsoft применяет тот же метод.
</p>

<a name="2_4_4"></a>
<div class="header"> 2.4.4 Динамическое связывание без импорта</div>
<p>
Вместо того, чтобы Windows выполняла динамическое связывание при первой загрузке программы в оперативную память, можно связать программу с модулем библиотеки во время выполнении программы. Например, можно было бы просто вызвать функцию <i>Rectangle()</i>:
</p>
<pre><div class="code">
Rectangle(hdc, xLeft, yTop, xRight, yBottom);
</div></pre>

<p>
Это работает, поскольку программа была скомпонована с библиотекой импорта <i>gdi32.lib</i>, в которой имеется адрес функции <i>Rectangle()</i>.
<br>Можно также вызвать функцию <i>Rectangle()</i> и совершенно необычным образом. Сначала используется оператор <i><b>typedef</i></b> для определения типа функции <i>Rectangle()</i>:
</p>
<pre><div class="code">
typedef BOOL(WINAPI *PFNRECT)(HDC, int, int, int, int);
</div></pre>
<p>Затем определяются две переменные:
</p>
<pre><div class="code">
HANDLE hLibrary;
PFNRECT pfnRectangle;
</div></pre>
<p>
Теперь устанавливаются значения переменных <i>hLibrary</i> равное описателю библиотеки, а значение переменной <i>pfnRectangle</i> – равным адресу функции <i>Rectangle()</i>:
</p>
<pre><div class="code">
hLibrary = LoadLibrary("gdi32.dll");
if (hLibrary)
{
	pfnRectangle = 
		(PFNRECT)GetProcAddress(hLibrary,"Rectangle");

//Теперь можно вызывать функцию и затем освободить библиотеку

	if (pfnRectangle)
		pfnRectangle(hdc, xLeft, yTop, xRight, yBottom);
	FreeLibrary(hLibrary);
}
</div></pre>
<p>
Если этот прием динамического связывания во время выполнения не имеет особого смысла для функции <i>Rectangle()</i>, то смысл определенно появляется, если до начала выполнения программы неизвестно имя модуля библиотеки.
</p>

<a name="3"></a>
<div class="header">3. Индивидуальные задания</div>

<p>
Находятся в файле <a href="Индивидуальные задания_06.html" target="_blank">« Индивидуальные задания »</a>
</p>
<center>[<a href="Лабораторная работа №5.html">Предыдущая работа</a>][<a href="#0">Оглавление</a>][<a href="index.html">Содержание</a>][<a href="Лабораторная работа №7.html">Следующая работа</a>]</center>

</p>
</body>
</p>
</html>