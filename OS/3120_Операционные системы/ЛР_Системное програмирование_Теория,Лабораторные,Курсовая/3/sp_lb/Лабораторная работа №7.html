<html>
<head>
<title>ЛАБОРАТОРНАЯ РАБОТА №7</title>
<link href=style.css rel=stylesheet type=text/css>
</head>
<body>
<div class="title"><A name=REF_1_C></A>ЛАБОРАТОРНАЯ РАБОТА №7</div><br>
<div class="title"><A name=REF_1_1_1></A>ПРОЦЕССЫ И ПОТОКИ</div>

<p>
<center>[<a href="Лабораторная работа №6.html">Предыдущая работа</a>][<a href="#0">Оглавление</a>][<a href="index.html">Содержание</a>][<a href="Лабораторная работа №8.html">Следующая работа</a>]</center>
		
<br>
<br>
<div class="title">

<a name="0"></a>Оглавление</div>
		
<ol type="1">
			
<li>
<a href="#1">Цель работы</a>			
</li>
			
<li>		
<a href="#2">Многозадачность и многопоточность в Windows</a>
</li>
			
<ul>
			
<li>				
<a href="#2_1">Процессы</a>
</li>
			
<li>
<a href="#2_2">Вызов CreateProcess</a>
</li>
			
<li>
<a href="#2_3">Задания и рабочие наборы</a>
</li>
</ul>
			
<li>
<a href="#3">Потоки. Общие сведения</a>
</li>
<ul>			
<li>
<a href="#3_1">Создание вторичных потоков</a>
</li>
			
<li>
<a href="#3_2">Прекращение выполнения потока</a>
</li>


			
<li>
<a href="#3_3">Управление потокоми</a>
</li>

</ul>

<li>
<a href="#4">Индивидуальные задания</a>			
</li>
		
</ol>
		
<br>
<br>

<p>
<a name="1"></a>
<div class="header">1. Цель работы</div>
</p>
<p>
Ознакомление с понятиями процессов и потоков в ОС Windows, приобретение практических навыков создания и использования процессов и потоков.
</p>
<a name="2"></a>
<div class="header">2. Многозадачность и многопоточность в Windows</div>

<p>
<i>Многозадачность (multitasking)</i> – это способность операционной системы выполнять несколько программ одновременно. В основе этого принципа лежит использование операционной системой аппаратного таймера для выделения отрезков времени (<i>time slices</i>) для каждого из одновременно выполняемых процессов. Если эти отрезки времени достаточно малы и машина не перегружена слишком большим числом программ, то пользователю кажется, что все эти программы выполняются параллельно.
<br><br>Идея многозадачности не нова. Многозадачность реализуется на больших компьютерах типа <i>мэйнфрэйм (mainframe)</i>, к которым подключены десятки, а иногда и сотни терминалов. У каждого пользователя, сидящего за экраном такого терминала, создается впечатление, что он имеет эксклюзивный доступ ко всей машине. Кроме того, операционные системы мэйнфрэймов часто дают возможность пользователям перевести задачу в фоновый режим, где она выполняется, в то время как пользователь работает с другой программой. Windows NT и Windows 9х – 32-разрядные версии Windows – поддерживают кроме многозадачности еще и <i>многопоточность (multithreading)</i>.
<br><br><i>Многопоточность</i> – это возможность программы самой быть многозадачной. Программа может быть разделена на отдельные потоки выполнения (<i>threads</i>), которые выполняются псевдопараллельно. На первый взгляд эта концепция может показаться едва ли полезной, но оказывается, что программы могут использовать многопоточность для выполнения протяженных во времени операций в фоновом режиме, не вынуждая пользователя надолго отрываться от машины.
</p>
<a name="2_1"></a>
<div class="header">2.1. Процессы</div>
<p>
Если нужно запустить новую программу, следует создать новый процесс. Для этого используется стандартный системный вызов <i>CreateProcess()</i>. Однако пользоваться им не очень удобно – приходится определять значения множества аргументов. Что делать, если необходимо запустить WordPad только для того, чтобы отобразить содержимое файла <i>«readme.txt»</i>? Для этой цели можно использовать менее сложный механизм – вызов функции <i>WinExec()</i>. При обращении к <i>WinExec()</i> необходимо сообщить имя программы (полный путь или короткое имя исполняемого файла, расположенного в пути поиска), а также способ отображения окна программы (константа, используемая функцией <i>ShowWindow(), SW_SHOW, SW_HIDE</i> и т. д.).
<br>В случае, если произошла ошибка, функция <i>WinExec()</i> возвращает значение, меньшее 32. Если программа успешно запущена, функция возвращает дескриптор новой программы (который не может быть меньше 32). После запуска новой программы функция <i>WinExec()</i> немедленно передает управление программе, из которой был осуществлен вызов, т.е. она не ждет момента, пока вновь запущенная программа завершит работу.
<br><br>Еще один простой вызов, который можно использовать для запуска программ, – это <i>ShellExecute()</i>. Он во многом напоминает <i>WinExec()</i>, но еще поддерживает обработку типов файлов, зарегистрированных графической оболочкой операционной системы. Например, если при помощи <i>ShellExecute()</i> попробовать запустить файл с расширением <i>.txt</i>, будет запущена программа notepad.exe или любая другая программа, которая используется в системе для просмотра текстовых файлов. В качестве аргументов функция <i>ShellExecute()</i> принимает дескриптор окна (на случай, если возникнет необходимость в сообщениях об ошибках) и операционную строку, такую как "open" (открыть), "print" (распечатать) или "explore" (исследовать). В качестве операционной строки можно передать <i>NULL</i>-строку, в этом случае указанный файл будет открыт ("open"). Также функции <i>ShellExecute()</i> необходимо сообщить имя файла и любые параметры командной строки (обычно <i>NULL</i>). Наконец, последние два аргумента – это текущий каталог и константа функции <i>ShowWindow()</i> (как и в случае с <i>WinExec()</i>).
<br>Возвращаемое значение точно такое же, как и у <i>WinExec()</i>. Если указать в качестве третьего аргумента функции <i>ShellExecute()</i> имя исполняемого файла, можно не использовать другие аргументы, кроме аргумента параметров командной строки и константы <i>ShowWindow()</i>. Для файлов документов (например, *.txt или *.doc) значение этих аргументов обычно равно <i>NULL</i>.
<br>Функцию <i>ShellExecute()</i> можно использовать, например, для того, чтобы открыть корневой каталог диска С:
</p>

<pre><div class="code">
ShellExecute(hWnd,"open","c:\\",NULL,NULL,SW_SHOWNORMAL);
</div></pre>

<p>
Можно заменить строку "open" на строку "explore", а также указать в качестве третьего параметра имя абсолютно любого каталога.
<br>Ниже приведен пример простой консольной программы.
</p>

<pre><div class="code">
#include <windows.h>
#include <stdlib.h>

void main()
{
	printf("Opening with WinExec\n");

	if (WinExec("notepad.exe readme.txt", SW_SHOW) < 32)
		MessageBox(NULL, "Ошибка открытия", NULL, MB_OK);
	else
		MessageBox(NULL,"Нажмите OK для продолжения",
					"Программа открыта",MB_OK);

	printf("Opening with ShellExecute\n)";

	if (ShellExecute(NULL,"open","readme.txt",NULL,
			NULL,SW_SHOW) < 32)
		MessageBox(NULL, "Ошибка открытия", NULL, MB_OK);
	else
		MessageBox(NULL,"Нажмите OK для продолжения",
					"Программа открыта",MB_OK);
}
</pre></div>

<p>
Программа открывает текстовый файл, используя при этом два различных способа. Сначала происходит обращение к функции <i>WinExec()</i>, которой напрямую сообщаются имя программы текстового редактора и имя текстового файла, который должна открыть эта программа. Затем для открытия того же файла используется системный вызов <i>ShellExecute()</i> (при этом, скорее всего, будет запущен <i>WordPad</i> или другая программа, ответственная в системе за открытие текстовых файлов).
</p>
<a name="2_2"></a>
<div class="header">2.2. Вызов CreateProcess</div>
<p>
Вызовы наподобие <i>ShellExecute()</i> и <i>WinExec()</i> очень удобно использовать для выполнения простейших действий, вроде открытия файлов и запуска программ. Если же необходимо создать новый процесс, используя при этом некоторые дополнительные параметры, следует использовать системный вызов <i>CreateProcess()</i>. Описание аргументов, принимаемых этим вызовом, приведено ниже.
</p>

<p>
Аргументы вызова <i>CreateProcess()</i>:
<ul>
	<i>lpApplicationName</i> – имя программы (или <i>NULL</i>, если имя программы указано в командной строке);
	<br><i>lpCommandLine</i> – командная строка;
	<br><i>lpProcessAttributes</i> – атрибуты безопасности для дескриптора процесса, возвращаемого функцией
	<br><i>lpThreadAttributes</i> – атрибуты безопасности для дескриптора потока, возвращаемого функцией
	<br><i>bInheritHandlers</i> – указывает, наследует ли новый процесс дескрипторы, принадлежащие текущему процессу
	<br><i>dwCreationFlags</i> – параметры создания процесса (см. таблицу 2)
	<br><i>lpEnvironment</i> – значения переменных окружения (или <i>NULL</i>, в случае если наследуется текущее окружение)
	<br><i>lpCurrentDlrectory</i> – текущий каталог (или <i>NULL</i>, если используется текущий каталог текущего процесса)
	<br><i>lpProcessInformation</i> – возвращаемые функцией дескрипторы и идентификаторы ID процесса и потока
	<br><i>lpStartupInfo</i> – указатель на структуру <i>STARTUPINFO</i>, содержащую информацию о запуске процесса
</ul>
Значения параметра <i>dwCreationFlags</i>, используемые при создании процесса:
<ul>
	CREATE_DEFAULT_ERROR_MODE – не наследовать текущий режим сообщений об ошибках (см. <i>SetErrorMode()</i>);
	<br><i>CREATE_NEW_CONSOLE</i> – создать новую консоль;
	<br><i>CREATE_NEW_PROCESS_GROUP</i> – создать новую группу процессов;
	<br><i>CREATE_SEPARATE_WOW_VDM</i> – запустить 16-битное приложение в его собственном адресном пространстве;
	<br><i>CREATE_SHARED_WOW_VDM</i> – запустить 16-битное приложение в адресном пространстве общего доступа;
	<br><i>CREATE_SUSPENDED</i> – создать процесс в приостановленном состоянии (см. <i>ResumeThread()</i>);
	<br><i>CREATE_UNICODE_ENVIRONMENT</i> – блок переменных окружения записан в формате <i>UNICODE</i>;
	<br><i>DEBUG_PROCESS</i> – запустить процесс в отладочном режиме;
	<br><i>DEBUG_ONLY_TH1S_PROCESS</i> – предотвратить отладку процесса текущим отладчиком (используется при отладке родительского процесса);
	<br><i>DETACHED_PROCESS</i> – новый консольный процесс не имеет доступа к консоли родительского процесса.
</ul>
Аргумент <i>lpStartupInfo</i> – это указатель на структуру <i>STARTUPINFO</i>. Поля этой структуры содержат заголовок консоли, начальный размер и позицию нового окна и перенаправление стандартных потоков ввода/вывода. Новая программа может проигнорировать все эти параметры в зависимости от собственного желания. 
<br><br>Поле <i>dwFlags</i> этой структуры содержит флаги, установленные в соответствии с тем, какие из остальных полей структуры необходимо было использовать при запуске новой программы. Например, если сбросить флаг <i>STARTUSEPOSITION</i>, поля <i>dwX</i> и <i>dwY</i> структуры <i>STARTUPINFO</i>, содержащие координаты основного окна запускаемой программы, будут проигнорированы.
<br><br>Функция <i>CreateProcess()</i> записывает в аргумент <i>lpProcessInformation</i> указатель на структуру, содержащую дескрипторы и идентификаторы ID нового процесса и потока. Доступ к этим дескрипторам определяется аргументами <i>lpProcessAttributes</i> и <i>lpThreadAttributes</i>.
<br>Некоторые аргументы функции <i>CreateProcess()</i> относятся к консольным приложениям, другие - имеют значение для всех типов программ. Зачастую при обращении к <i>CreateProcess()</i> можно не заполнять структуру <i>STARTUPINFO</i>, однако в любом случае нужно передать функции указатель на существующую в памяти структуру, даже если эта структура не заполнена.
<br>Функция <i>CreateProcess()</i> возвращает значение типа <i>BOOL</i>, но по завершении работы чрезвычайно полезная для программиста информация размещается функцией в структуре типа <i>PROCESS_INFORMATION</i>, указатель на которую возвращается при помощи параметра <i>lpProcessInformation</i> этой функции. В структуре <i>PROCESS_INFORMATION</i> содержатся идентификатор и дескриптор нового процесса, а также идентификатор и дескриптор самого первого потока, принадлежащего новому процессу. Эти сведения могут использоваться для того, чтобы сообщить о новом процессе другим программам, а также для того, чтобы контролировать новый процесс.
<br><br>При создании процесса с использованием вызова <i>CreateProcess()</i> можно передать новому процессу по наследству некоторые объекты, в частности дескрипторы открытых файлов. Однако, к сожалению, это редко когда бывает полезным, за исключением случаев, когда необходимо объединить стандартные потоки ввода/вывода нескольких консольных приложений. В этой ситуации дескрипторы файлов стандартных потоков ввода/вывода обладают заранее определенными значениями. Даже если новый процесс получает по наследству дескриптор открытого файла, он не может определить его значения, если только оно не определено заранее. Можно передать дескриптор в командной строке или в переменной окружения, однако, это не очень удобный вариант.
<br><br>Обладая дескриптором процесса, можно управлять процессом при помощи следующих вызовов:
<ul>
	<i>GetExitCodeProcess()</i> – возвращает код завершения процесса;
	<br><i>GetGuiRecources()</i> – определяет, сколько объектов USER или GDI  используется процессом;
	<br><i>SetPrlorityClass()</i> – устанавливает базовый приоритет процесса;
	<br><i>GetPriorityClass()</i> – возвращает базовый приоритет процесса;
	<br><i>SetProcessAffinityMask()</i> – определяет, какие из процессоров используются процессом в качестве основных;
	<br><i>GetProcessAffinityMask()</i> – устанавливает, какие из процессоров используются процессом в качестве основных;
	<br><i>SetProcessPriorityBoost()</i> – позволяет или запрещает Windows динамически изменять приоритет процесса;
	<br><i>GetProcessPriorityBoost()</i> – возвращает статус изменения приоритета процесса;
	<br><i>SetProcessShutDownParameters()</i> – определяет, в каком порядке система закрывает процессы при завершении работы всей системы;
	<br><i>GetProcessShutDownParameter()</i> – возвращает статус механизма завершения работы системы;
	<br><i>SetProcessWorkingSetSize()</i> – устанавливает минимальный и максимальный допустимый объем физической оперативной памяти, используемый процессом;
	<br><i>GetProcessWorkingSetSize()</i> – возвращает информацию об использованиифизической памяти процессом;
	<br><i>TerminateProcess()</i> – корректное завершение работы процесса;
	<br><i>ExitProcess()</i> – немедленное завершение процесса;
	<br><i>GetProcessversion()</i> – возвращает версию Windows, в среде которой хотел бы работать процесс;
	<br><i>GetProcessTimes()</i> – возвращает степень использования CPU процессом;
	<br><i>GetStartUpInfo()</i> – возвращает переданную процессу при обращениик CreateProcess() структуру <i>STARTUPINFO</i>.
</ul>
Чтобы определить момент завершения процесса, можно воспользоваться одним из нескольких методов, Во-первых, можно использовать вызов <i>GetExitCodeProcess()</i>, который возвращает либо значение <i>STILL_ACTIVE</i> (если процесс еще продолжает работу), либо код завершения процесса (если процесс завершен). В качестве одного из аргументов этой функции передается указатель на переменную, в которую помещается возвращаемое значение. Узнать дескриптор текущего процесса можно при помощи функции <i>GetCurrentProcess()</i>. Чтобы управлять процессом из другого процесса, следует обратиться к функции <i>OpenProcess()</i>, которой необходимо передать идентификатор процесса. Чтобы открыть процесс для желаемого доступа, нужно обладать необходимыми разрешениями на доступ к процессу. Процесс, создающий новый процесс при помощи функции <i>CreateProcess()</i>, уже обладает дескриптором нового процесса.
<br><br>Еще один способ определения текущего состояния процесса подразумевает использование функции <i>WaitForSingleObject()</i>. Этот вызов можно использовать для самых разных целей. Основное назначение <i>WaitForSingleObject()</i> – определить, находится ли некоторый дескриптор в сигнальном состоянии. Дескриптор процесса переходит в сигнальное состояние тогда, когда процесс завершает свою работу. При обращении к функции <i>WaitForSingleObject()</i> необходимо указать дескриптор процесса и интервал времени в миллисекундах. Если интервал времени равен 0, функция завершает работу немедленно, возвращая текущее состояние процесса. Если интервал времени равен константе <i>INFINIT</i>, функция будет ждать до тех пор, пока интересующий вас процесс не завершит работу. Если указать конкретное значение интервала времени, функция будет ожидать завершения процесса в течение указанного времени, а затем вернет управление вызвавшей ее программе. Если в течение указанного времени процесс завершит работу, <i>WaitForSingleObject()</i> вернет управление вызвавшей программе и сообщит ей, что дескриптор целевого процесса перешел в сигнальное состояние. В противном случае эта функция вернет отрицательный ответ.
<br><br>Вне зависимости от того, в каком состоянии находится дескриптор целевого процесса, функция <i>WaitForSingleObject()</i> также возвращает значение, отражающее успешное выполнение – дескриптор так и не перешел в сигнальное состояние, что не является ошибкой. Чтобы определить состояние процесса, необходимо сравнить значение, которое вернула функция, со значениями <i>WAIT_OBJECT_0</i> (сигнальное состояние) и WAIT_TIMEOUT (процесс продолжает функционировать). В случае ошибки функция вернет значение <i>WAIT_FAILED</i>.
<br><br>Чтобы иметь возможность ожидать завершения процесса, нужно обладать открытым дескриптором этого процесса с привилегией <i>SYNCHRONIZE</i>. Следует помнить, что идентификатор процесса – это не то же самое, что дескриптор процесса. Дескрипторы процессов нельзя просто так передавать из процесса в процесс. Это означает, что если требуется управлять процессом из другого процесса, то следует, прежде всего, каким-либо образом получить дескриптор управляемого процесса. Для идентификации процесса другими процессами служит идентификатор ID этого процесса, который можно передать из процесса в процесс. Преобразовать идентификатор ID процесса в его дескриптор можно при помощи функции <i>OpenProcess()</i>, однако для этого требуется обладать необходимыми привилегиями. Узнать идентификатор текущего процесса можно при помощи функции GetCurrentProcessId(). Используя этот вызов, можно узнать идентификатор собственного процесса и передать этот идентификатор другому процессу. Получив ID вашего процесса, другой процесс сможет открыть его дескриптор.
<br><br>При обращении к функции <i>OpenProcess()</i> необходимо указать требуемый уровень доступа к открываемому процессу. Иногда получить доступ к процессу на любом из возможных уровней нельзя, поэтому, выбирая уровень, нужно использовать именно тот, который необходим для выполнения задачи, и не более того. Например, чтобы узнать код завершения процесса, достаточно владеть уровнем доступа <i>PROCESS_QUERY_INFORMATION</i>. Чтобы иметь возможность завершить работу процесса, необходимо обладать уровнем доступа <i>PROCESS_TERMINATE</i>. Можно запросить предоставление полного набора прав доступа к процессу, для этого предназначен уровень доступа <i>PROCESS_ALL_ACCESS</i>.
<br><br>При помощи вызова <i>LoginUser()</i> программа, обладающая необходимой привилегией (конкретно <i>SE_TCB_NAME</i>), может определить лексему (<i>token</i>) подключенного к системе пользователя. Обладая этой лексемой, можно запустить какой-либо процесс от имени пользователя системы. Другими словами, действия, которые выполняет процесс, будут рассматриваться системой как действия, выполняемые пользователем системы. Запуск процесса от имени пользователя осуществляется при помощи вызова <i>CreateProcessAsUser()</i>, при этом программа будет запущена от лица пользователя, обладающего указанной лексемой.
<br><br>В приведенных ниже примерах создаются два простых консольных приложения. Первая программа (MASTER) запускает вторую (SLAVE) и переходит в режим ожидания. Программа SLAVE читает идентификатор процесса (PID – Process Identifier) запустившей ее программы из командной строки и ожидает завершения работы программы MASTER. В командной строке программы MASTER можно указать полный путь к исполняемому файлу программы SLAVE. Обе программы иллюстрируют несколько важных технологий использования функций <i>CreateProcess(), OpenProcess()</i> и <i>WaitForSingleObject()</i>.
<br>Следует обратить внимание, что MASTER не использует большую часть аргументов функции <i>CreateProcess()</i>, поэтому в данном конкретном случае для запуска SLAVE вполне можно использовать вызов <i>WinExec()</i>.
</p>

<pre><div class="code">
Программа MASTER:

#include <windows.h>
#include <stdlib.h>
#include <string.h>

void main(int argc, char *argv[])
{
  char cmd[128];
  if (argc!=1) strcpy(cmd, argv[1]);
  else strcpy(cmd, "slave.exe");
  int pid = GetCurrentProcessId();
  sprintf(cmd + strlen(cmd)," %d", pid);
  printf("Master: Starting:%d \n", pid);

//In this case, might just as well use WinExec
//if (WinExec(cmd,SW_SHOW) < 32)
//  printf("Master: Slave process did not start\n");
  printf("Master: Try naming slave process on the command line\n");
     }
     cout<<"Master: Sleeping\n";
     cout.flush();

     Sleep(15000);
     cout<<"Master: Exiting\n";
     exit(0);
 }


Программа SLAVE:

#include <windows.h>
#include <stdlib.h>
#include <string.h>

void main(int argc,char *argv[])
{
    if (argc!=2)
    {
       cerr<<"Slave: Please run MASTER.EXE instead.\n";
       exit(1);
    }

   int pid=atoi(argv[1]);
   HANDLE process=OpenProcess
    (PROCESS_QUERY_INFORMATION|SYNCHRONIZE,FALSE,pid);

   if (!process) cout<<"Slave: Error opening process\n";
   cout<<"Slave: Waiting for master to finish\n";
   cout.flush();

   if (WaitForSingleObject(process,INFINITE)==
       STATUS_WAIT_0)
       cout<<"Slave: Master completed\n";
   else
       cout<<"Slave: Unexpected error\n";
       exit(0);
 }

</div></pre>

<a name="2_3"></a>
<div class="header">2.3. Задания и рабочие наборы</div>

<p>
Обычно каждому процессу в Windows 2000 назначается так называемый рабочий набор (<i>working set</i>). Рабочий набор процесса определяет, какой объем физической памяти диспетчер памяти Windows пытается сохранить за данным процессом. В рабочем наборе указываются минимальное и максимальное количества страниц памяти, которые должны принадлежать данному процессу. Узнать текущий размер можно при помощи вызова <i>GetProcessWorkingSize()</i>. Если объем памяти, доступный для других приложений, становится неприемлемо маленьким, система может нарушить границы, установленные в рабочем наборе той или иной программы. Обладая необходимыми для этого привилегиями, программа может изменить собственный рабочий набор при помощи функции <i>SetProcessWorkingSetSize()</i>. Если обе границы становятся равными 0xFFFFFFFF, Windows сбрасывает на диск всю память, принадлежащую процессу.
<br><br>Еще одним методом управления процессами в Windows 2000 является задание (<i>job</i>) – это группа связанных между собой процессов. Создать задание можно при помощи функции <i>CreateJobObject()</i>, а открыть существующее задание можно при помощи функции <i>OpenJobObject()</i>. Обладая дескриптором задания, можно добавить к нему любые другие процессы при помощи функции <i>AssignProcessToJobObject()</i>.
<br>Для объединения процессов в группу может быть несколько причин. Например, используя функцию <i>TerminateJobObject()</i>, можно разом завершить работу всех процессов одного задания. При помощи вызова <i>SetInformationJobObject()</i> можно установить рабочий набор одновременно для всей группы процессов, входящих в задание. Этот же вызов можно использовать для назначения ограничений всем процессам, входящим в задание. В частности, можно запретить всему заданию обращаться к системному вызову <i>ExitWindows()</i>, читать содержимое системного буфера обмена или использовать какие-либо дескрипторы (например, дескрипторы окон) других процессов. Если запрещен доступ к пользовательским дескрипторам процессов одного задания, то процесс, не принадлежащий этому заданию, может предоставить его процессам доступ к пользовательскому дескриптору при помощи функции <i>UserHandleGrantAccess()</i>.
<br>Помимо прочего операционная система позволяет получать статистику, связанную с процессами задания. Для этого служит вызов <i>QueryInformationObject()</i>, используя который можно получить информацию о том, какую нагрузку на центральный процессор создают процессы, входящие в состав задания, а также другую подобную информацию. Кроме того, при помощи этого вызова можно получить информацию о параметрах конфигурации задания, значения которым присваиваются при помощи функции <i>SetInformationObject()</i>.
</p>
<a name="3"></a>
<div class="header">3. Потоки. Общие сведения</div>

<p>
Термин поток (<i>thread</i>) означает выполнение некоторой последовательности инструкций кода программы. Все программы, представленные ранее в лабораторных работах, выполняются одним потоком, называемым первичным потоком. Однако программа, написанная для Windows, может запустить один или более вторичных потоков, каждый из которых независимо выполняет набор инструкций программного кода. С точки зрения пользователя, потоки в программе выполняются одновременно. Операционная система (ОС) обычно достигает этого за счет быстрого переключения управления с одного потока на другой (однако, если компьютер имеет более одного процессора, ОС может выполнять потоки действительно одновременно).
</p>
<a name="3_1"></a>
<div class="header">3.1. Создание вторичных потоков</div>

<p>
Многопоточность особенно полезна в Windows-программе в тех случаях, когда первичный поток программы, допустим, посвящен обработке сообщений, при этом можно обеспечить быстрые ответы программы на команды и другие события. Вторичный поток может быть использован для выполнения некоторой длинной задачи, которая должна блокировать обработку сообщений программы, если выполняется первичный поток. Например, рисование сложной графики, пересчет электронных таблиц, выполнение дисковых операций, связь с последовательным портом. Запуск отдельного потока программы выполняется относительно быстро и занимает немного памяти. Кроме того, все потоки внутри программы выполняются в одном и том же адресном пространстве памяти и используют один и тот же набор ресурсов Windows.
<br>В программах Win32 можно достаточно свободно использовать многопоточность, при условии, что соблюдаются определенные правила.
<br>Для запуска нового потока вызывается функция <i>CreateThread()</i>, которая имеет следующий формат:
</p>

<pre><div class="code">
HANDLE CreateThread(
  LPSECURITY_ATTRIBUTES lpThreadAttributes,
  DWORD dwStackSize,
  LPTHREAD_START_ROUTINE lpStartAddress,
  LPVOID lpParameter,
  DWORD dwCreationFlags,
  LPDWORD lpThreadId);
</div></pre>

<p>
Параметры функции следующие:
<ul>
	<i>lpThreadAttributes</i> – указатель на структуру <i>SECURITY_ATTRIBUTES</i>, которая содержит дескриптор защиты. Используется в Windows NT (значение, равное <i>NULL</i>, указывает на то, что новый поток получит дескриптор защиты по умолчанию), для Windows 9x этот параметр игнорируется;
	<br><i>dwStackSize</i> – размер стека для потока (в байтах);
	<br><i>lpStartAddress</i> – адрес функции, которая будет выполняться в потоке. 
</ul>
Ее прототип должен быть следующим:
</p>

<pre><div class="code">
DWORD WINAPI ThreadFunc(LPVOID);
</div></pre>

<p>
<ul>
	<i>lpParameter</i> – 32-разрядное значение, которое будет передаваться в функцию потока;
	<br><i>dwCreationFlags</i> – дополнительный флаг для управления созданием потока. Если использовать значение, равное <i>CREATE_SUSPENDED</i>, то поток будет создан в приостановленном состоянии и не выполняется, пока для него не будет вызвана функция <i>ResumeThread()</i>. Если значение флага равно 0, то поток начнет свое выполнение немедленно после создания. Других значений флага не предусмотрено;
	<br><i>lpThreadId</i> – указатель на 32-разрядную переменную, которая получит идентификатор созданного потока.
</ul>
<i>CreateThread()</i> запускает выполнение нового потока и быстро возвращает управление. С этого момента оба потока – новый и тот, который вызвал <i>CreateThread()</i>, работают одновременно. Третий параметр <i>lpStartAddress</i> задает функцию потока; новый поток начинает выполнять эту функцию. Функция потока может вызывать другие функции, но когда происходит возврат из функции потока, созданный поток завершается.
<br>Функция потока возвращает значение типа <i>DWORD</i>, это значение называется кодом завершения, и другие потоки могут его использовать. Обычно функция потока возвращает значение 0, указывающее на нормальное его завершение.
<br>Информацию в новый поток можно передать через указатель <i>lpParameter</i>, который передается в функцию потока. Этот указатель может содержать адрес простого числа, например типа <b>int</b>, или адрес структуры, содержащей любое количество информации. Аналогично поток может возвращать информацию начальному потоку, присваивая значение элементу данных, на который указывает параметр lpParameter.
<br><br>Следующий пример кода начинает новый поток, выполняющий функцию <i>ThreadFunction()</i>:
</p>

<pre><div class="code">
DWORD WINAPI ThreadFunction (LPVOID lpParam)
{
	// предложения и функциональные вызовы,
	// которые должны быть выполнены новым потоком
	//...
	return 0;
}

void SomeFunction (void)
{
	//...
	int Code = 1;
	DWORD ThreadId;
	HANDLE hThread;

	hThread = CreateThread(NULL, 0, ThreadFunction,
						&Code, 0, &ThreadId);

	CloseHandle(hThread);
}
</div></pre>
<a name="3_2"></a>
<div class="header">3.2. Прекращение выполнения потока</div>

<p>
Можно завершить запущенный поток одним из двух способов. Во-первых, возможно просто получить возврат потока из функции потока (как в примере выше), передавая обратно желаемый код выхода. Это наиболее правильный способ завершения потока; стек, используемый потоком, будет освобожден и все данные объектов, автоматически созданные потоком, будут разрушены (т.е. будут вызваны деструкторы для автоматически созданных объектов). Во-вторых, поток может вызвать функцию API <i>ExitThread()</i>, передавая ей желаемый код выхода:
</p>

<pre><div class="code">
VOID ExitThread(DWORD dwExitCode);
</div></pre>

<p>
Вызов <i>ExitThread()</i> – это удобный способ немедленно завершить поток из вложенной функции (вместо возврата в начальную функцию потока). При использовании этого метода стек потока будет освобожден, но деструкторы для автоматических данных объектов не будут вызваны.
Оба эти способа завершения потока должны быть выполнены самим потоком. Если необходимо завершить поток из другого потока, то этому другому потоку следует передавать сигнал в поток, который нужно закончить, требуя завершения его своими средствами. Кроме этого, поток можно завершить из другого с помощью функции <i>TerminateThread()</i>. Прототип ее следующий:
</p>

<pre><div class="code">
BOOL TerminateThread(HANDLE hThread,
                     DWORD dwExitCode);
</div></pre>

<p>
где <i>hThread</i> – идентификатор завершаемого потока, а <i>dwExitCode</i> – код возврата.
</p>
<a name="3_3"></a>
<div class="header">3.3. Управление потокоми</div>

<p>
<i>CreateThread()</i> возвращает дескриптор созданного потока, который затем может использоваться для управления потоком. Можно вызвать функцию <i>SuspendThread()</i>, чтобы временно приостановить выполнение потока:
</p>

<pre><div class="code">
DWORD SuspendThread(HANDLE hThread);
</div></pre>

<p>
Чтобы снова запустить выполнение потока можно вызвать функцию <i>ResumeThread()</i>:
</p>

<pre><div class="code">
DWORD ResumeThread(HANDLE hThread);
</div></pre>

<p>
Можно также вызвать <i>ResumeThread()</i> для запуска потока, созданного в приостановленном состоянии присваиванием значения <i>CREATE_SUSPEND</i> параметру <i>dwCreationFlags</i> функции <i>CreateThread()</i>. Кроме того, можно изменить приоритет потока с уровня, изначально присвоенного в вызове CreateThread(), вызывая <i>SetThreadPriority()</i>.
</p>

<pre><div class="code">
BOOL SetThreadPriority(HANDLE hThread,
                       int nPriority);
</div></pre>

<p>
Например, следующий код поднимает приоритет потока:
</p>

<pre><div class="code">
HANDLE hThread = CreateThread(/*... */);
//...
SetThreadPriority(hThread, THREAD_PRIORITY_ABOVE_NORMAL);
</div></pre>

<p>
Текущий уровень приоритета потока возвращается вызовом:
</p>

<pre><div class="code">
GetThreadPriority.
int GetThreadPriority(HANDLE hThread);
</div></pre>

<p>
Функция <i>GetExitCodeThread()</i> определяет, продолжается ли выполнение потока, и, если выполнение остановлено, получить его код возврата (т.е. значение, возвращенное из функции потока или функцией <i>ExitThread()</i>):
</p>

<pre><div class="code">
BOOL GetExitCodeThread(HANDLE hThread, LPDWORD lpExitCode);
</div></pre>

<p>
Пример использования функции <i>GetExitCodeThread()</i>:
</p>

<pre><div class="code">
DWORD ExitCode;
HANDLE hThread;
hThread = CreateThread(/*... */);
//...
GetExitCodeThread(hThread, &ExitCode);
if(ExitCode == STILL_ACTIVE )
{
	// поток продолжает выполнение
}
else
{
	// поток завершен и ExitCode содержит код выхода
}
</div></pre>

<p>
Как видно из примера, функция <i>GetExitCodeThread()</i> присваивает значение кода возврата переменной типа <i>DWORD</i>, адрес которой передан функции вторым параметром. Если поток продолжает выполнение, переменной присваивается значение <i>STILL_ACTIVE</i>; если поток завершился, переменной присваивается значение кода выхода.
</p>

<a name="4"></a>
<div class="header">4. Индивидуальные задания</div>

<p>
Находятся в файле <a href="Индивидуальные задания_07.html" target="_blank">« Индивидуальные задания »</a>
</p>
<center>[<a href="Лабораторная работа №6.html">Предыдущая работа</a>][<a href="#0">Оглавление</a>][<a href="index.html">Содержание</a>][<a href="Лабораторная работа №8.html">Следующая работа</a>]</center>

</a>
</p>
</body>
</html>